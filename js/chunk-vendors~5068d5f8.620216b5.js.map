{"version":3,"sources":["webpack:///./node_modules/v-charts/lib/index.js","webpack:///./node_modules/vue-class-component/dist/vue-class-component.esm.js","webpack:///./node_modules/v-clipboard/dist/index.min.js"],"names":[],"mappings":";;;;;AAAA;AACA,EAAE,KAA4D,4BAA4B,mBAAO,CAAC,MAAqB,GAAG,mBAAO,CAAC,MAA+B,GAAG,mBAAO,CAAC,MAA8B,GAAG,mBAAO,CAAC,MAAuB,GAAG,mBAAO,CAAC,MAAwB,GAAG,mBAAO,CAAC,MAAuB,GAAG,mBAAO,CAAC,MAA0B,GAAG,mBAAO,CAAC,MAAyB,GAAG,mBAAO,CAAC,MAAuB,GAAG,mBAAO,CAAC,MAA6B,GAAG,mBAAO,CAAC,MAAc,GAAG,mBAAO,CAAC,MAA0B,GAAG,mBAAO,CAAC,MAA2B,GAAG,mBAAO,CAAC,MAAiC,GAAG,mBAAO,CAAC,MAA2B,GAAG,mBAAO,CAAC,MAA+B,GAAG,mBAAO,CAAC,MAAgC,GAAG,mBAAO,CAAC,MAAyB,GAAG,mBAAO,CAAC,OAAwB,GAAG,mBAAO,CAAC,MAAoB,GAAG,mBAAO,CAAC,MAAmB;AACn1B,EAAE,SAC0C;AAC5C,CAAC,+BAA+B;;AAEhC;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B,iBAAiB,cAAc;AAC/B,kBAAkB;AAClB,KAAK;AACL;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,6DAA6D,0BAA0B,gBAAgB,iBAAiB,uBAAuB,qBAAqB;AACpK;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,yDAAyD;AACvG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;;AAEA;AACA,+CAA+C,EAAE;AACjD;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,gDAAgD,+DAA+D;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB;AACzB;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,+DAA+D;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB;AACzB;AACA,mBAAmB;AACnB;AACA;;AAEA,iBAAiB;AACjB,qBAAqB,4BAA4B,4BAA4B,kBAAkB,4CAA4C,cAAc,wBAAwB,cAAc,iCAAiC,cAAc,kCAAkC,2BAA2B,EAAE,iBAAiB,8BAA8B,oDAAoD,EAAE;AAClZ,KAAK;AACL;;AAEA,mBAAmB;AACnB,qBAAqB,4BAA4B,4BAA4B,kBAAkB,qCAAqC;AACpI,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,mBAAmB,QAAQ,GAAG,QAAQ;AACtC;AACA,8CAA8C;AAC9C,WAAW;AACX,SAAS;AACT,kBAAkB;AAClB,qCAAqC;AACrC,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,gBAAgB,yDAAyD;AACzE;AACA,OAAO;AACP,gBAAgB;AAChB,OAAO;AACP,gBAAgB;AAChB,OAAO;AACP,KAAK;;;AAGL;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP,iBAAiB;AACjB;AACA;AACA,OAAO;AACP,cAAc,gCAAgC;AAC9C,eAAe,iCAAiC;AAChD,qBAAqB,iBAAiB;AACtC,oBAAoB,iBAAiB;AACrC,uBAAuB,iBAAiB;AACxC,2BAA2B,iBAAiB;AAC5C,eAAe,eAAe;AAC9B,aAAa,wBAAwB;AACrC,eAAe,cAAc;AAC7B,uBAAuB,+BAA+B;AACtD,sBAAsB,+BAA+B;AACrD,uBAAuB,eAAe;AACtC,iBAAiB,eAAe;AAChC,iBAAiB,eAAe;AAChC,kBAAkB,eAAe;AACjC,kBAAkB,wBAAwB;AAC1C,iBAAiB,wBAAwB;AACzC,gBAAgB,wBAAwB;AACxC,oBAAoB;AACpB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD,yBAAyB,6BAA6B;AACtD,yBAAyB,iBAAiB;AAC1C,mBAAmB,+BAA+B;AAClD,oBAAoB,6BAA6B;AACjD,oBAAoB,2BAA2B;AAC/C,sBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,aAAa;AAC9F;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB,gBAAgB,EAAE;AAC9D;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,WAAW;AACnD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA,kDAAkD,+DAA+D;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,KAAK;AACL,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B,mBAAmB;AACnB,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uGAAuG;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,yCAAyC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD;AACA,4DAA4D;AAC5D;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,aAAa;AAC9B,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;;AAE/D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,mDAAmD,+DAA+D;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,cAAc;AACd,KAAK;AACL;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,cAAc;AACd,KAAK;AACL;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA,0BAA0B,SAAS,8BAA8B;AACjE,OAAO;AACP,KAAK;AACL;AACA,+CAA+C,SAAS,8BAA8B;AACtF,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY;AACZ;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB;AAChB,OAAO;AACP,KAAK;AACL;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,uBAAuB;AACrD,qCAAqC,2FAA2F;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,mBAAmB;AACnB;AACA,mCAAmC,qEAAqE;;AAExG;AACA,yBAAyB,gBAAgB;AACzC,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,gCAAgC,gBAAgB;AAChD;AACA;AACA,yBAAyB,eAAe;AACxC,OAAO;AACP,KAAK;AACL,mCAAmC,qEAAqE;;AAExG;AACA,yBAAyB,aAAa;AACtC,OAAO;AACP,KAAK;AACL,uBAAuB,kDAAkD;AACzE;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY;AACZ;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA,sBAAsB;AACtB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B,GAAG,4BAA4B;AAC5E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA,aAAa,+HAA+H,GAAG,+LAA+L;AAC9U;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,+CAA+C,uBAAuB,EAAE,GAAG,mJAAmJ;AAC3O;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uBAAuB,cAAc;AACrC;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,sDAAsD,qEAAqE;AAC3H,yDAAyD,yEAAyE;AAClI,sDAAsD,iEAAiE;AACvH,yDAAyD,yBAAyB;AAClF,8BAA8B,mBAAmB;AACjD,gCAAgC,aAAa;AAC7C,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,QAAQ,oBAAoB;AACnD,YAAY;AACZ;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,wDAAwD;AACxD;AACA,0DAA0D;AAC1D;AACA,wDAAwD;AACxD;AACA;;;AAGA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY;AACZ;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,YAAY;AACZ;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,YAAY;AACZ;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,kBAAkB;AAClB,SAAS;AACT;;AAEA,iCAAiC,yBAAyB;AAC1D;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,8BAA8B,qHAAqH;AACnJ,qDAAqD,qCAAqC;;AAE1F;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;;;;;;;;AC5kID;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qCAAqC,EAAE;AAC5F;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,WAAW,mDAAG,SAAS,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB,EAAE;AACxD,2CAA2C,iBAAiB,EAAE;AAC9D;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,QAAQ,KAAqC,EAAE,EAK1C;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C,oBAAoB,EAAE;AAChE;AACA;AACA;AACA;AACA,sCAAsC,mDAAG;AACzC;AACA,UAAU,mDAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KACuC,EAAE,EAI5C;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,kEAAS,EAAC;AACU;;;;;;;;AC/QnC,eAAe,KAAiD,oBAAoB,SAA2H,CAAC,iBAAiB,mBAAmB,cAAc,4BAA4B,YAAY,qBAAqB,2DAA2D,SAAS,mCAAmC,SAAS,qBAAqB,qCAAqC,oCAAoC,EAAE,iBAAiB,iCAAiC,iBAAiB,YAAY,UAAU,sBAAsB,mBAAmB,iDAAiD,uBAAuB,kBAAkB,aAAa,sCAAsC,SAAS,EAAE,kBAAkB,kDAAkD,0BAA0B,oBAAoB,SAAS,wDAAwD,SAAS,2EAA2E,oBAAoB,cAAc,UAAU,+EAA+E,qCAAqC,mCAAmC,6BAA6B,wBAAwB,4BAA4B,iGAAiG,gBAAgB,SAAS,IAAI,+BAA+B,SAAS,gBAAgB,uCAAuC,WAAW,oBAAoB,yBAAyB,kBAAkB,kBAAkB,eAAe,QAAQ,eAAe,2BAA2B,eAAe,UAAU,iBAAiB,yBAAyB,mBAAmB,sBAAsB,UAAU,uBAAuB,+CAA+C,yBAAyB,iDAAiD,0BAA0B,8BAA8B,OAAO,yCAAyC,uFAAuF,SAAS,QAAQ,gFAAgF,oBAAoB,gGAAgG,yDAAyD,IAAI,GAAG;AACx5E,qC","file":"js/chunk-vendors~5068d5f8.620216b5.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('echarts/lib/echarts'), require('echarts/lib/component/tooltip'), require('echarts/lib/component/legend'), require('echarts/lib/chart/bar'), require('echarts/lib/chart/line'), require('echarts/lib/chart/pie'), require('echarts/lib/chart/funnel'), require('echarts/lib/chart/radar'), require('echarts/lib/chart/map'), require('echarts/extension/bmap/bmap'), require('echarts-amap'), require('echarts/lib/chart/sankey'), require('echarts/lib/chart/heatmap'), require('echarts/lib/component/visualMap'), require('echarts/lib/chart/scatter'), require('echarts/lib/chart/candlestick'), require('echarts/lib/component/dataZoom'), require('echarts/lib/chart/gauge'), require('echarts/lib/chart/tree'), require('echarts-liquidfill'), require('echarts-wordcloud')) :\n  typeof define === 'function' && define.amd ? define(['echarts/lib/echarts', 'echarts/lib/component/tooltip', 'echarts/lib/component/legend', 'echarts/lib/chart/bar', 'echarts/lib/chart/line', 'echarts/lib/chart/pie', 'echarts/lib/chart/funnel', 'echarts/lib/chart/radar', 'echarts/lib/chart/map', 'echarts/extension/bmap/bmap', 'echarts-amap', 'echarts/lib/chart/sankey', 'echarts/lib/chart/heatmap', 'echarts/lib/component/visualMap', 'echarts/lib/chart/scatter', 'echarts/lib/chart/candlestick', 'echarts/lib/component/dataZoom', 'echarts/lib/chart/gauge', 'echarts/lib/chart/tree', 'echarts-liquidfill', 'echarts-wordcloud'], factory) :\n  (global.VeIndex = factory(global.echarts));\n}(this, (function (echartsLib) { 'use strict';\n\n  echartsLib = echartsLib && echartsLib.hasOwnProperty('default') ? echartsLib['default'] : echartsLib;\n\n  var DEFAULT_THEME = {\n    categoryAxis: {\n      axisLine: { show: false },\n      axisTick: { show: false },\n      splitLine: { show: false }\n    },\n    valueAxis: {\n      axisLine: { show: false }\n    },\n    line: {\n      smooth: true\n    },\n    grid: {\n      containLabel: true,\n      left: 10,\n      right: 10\n    }\n  };\n\n  var DEFAULT_COLORS = ['#19d4ae', '#5ab1ef', '#fa6e86', '#ffb980', '#0067a6', '#c4b4e4', '#d87a80', '#9cbbff', '#d9d0c7', '#87a997', '#d49ea2', '#5b4947', '#7ba3a8'];\n\n  var HEAT_MAP_COLOR = ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026'];\n\n  var HEAT_BMAP_COLOR = ['blue', 'blue', 'green', 'yellow', 'red'];\n\n  var itemPoint = function itemPoint(color) {\n    return ['<span style=\"', 'background-color:' + color + ';', 'display: inline-block;', 'width: 10px;', 'height: 10px;', 'border-radius: 50%;', 'margin-right:2px;', '\"></span>'].join('');\n  };\n\n  var STATIC_PROPS = ['initOptions', 'loading', 'dataEmpty', 'judgeWidth', 'widthChangeDelay'];\n\n  var ECHARTS_SETTINGS = ['grid', 'dataZoom', 'visualMap', 'toolbox', 'title', 'legend', 'xAxis', 'yAxis', 'radar', 'tooltip', 'axisPointer', 'brush', 'geo', 'timeline', 'graphic', 'series', 'backgroundColor', 'textStyle'];\n\n  var ABBR = {\n    th: 3,\n    mi: 6,\n    bi: 9,\n    tr: 12\n  };\n\n  var DEFAULT_OPTIONS = {\n    zeroFormat: null,\n    nullFormat: null,\n    defaultFormat: '0,0',\n    scalePercentBy100: true,\n    abbrLabel: {\n      th: 'k',\n      mi: 'm',\n      bi: 'b',\n      tr: 't'\n    }\n  };\n\n  var TRILLION = 1e12;\n  var BILLION = 1e9;\n  var MILLION = 1e6;\n  var THOUSAND = 1e3;\n\n  function numIsNaN(value) {\n    return typeof value === 'number' && isNaN(value);\n  }\n\n  function toFixed(value, maxDecimals, roundingFunction, optionals) {\n    var splitValue = value.toString().split('.');\n    var minDecimals = maxDecimals - (optionals || 0);\n    var boundedPrecision = splitValue.length === 2 ? Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals) : minDecimals;\n    var power = Math.pow(10, boundedPrecision);\n    var output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);\n\n    if (optionals > maxDecimals - boundedPrecision) {\n      var optionalsRegExp = new RegExp('\\\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');\n      output = output.replace(optionalsRegExp, '');\n    }\n\n    return output;\n  }\n\n  function numberToFormat(options, value, format, roundingFunction) {\n    var abs = Math.abs(value);\n    var negP = false;\n    var optDec = false;\n    var abbr = '';\n    var decimal = '';\n    var neg = false;\n    var abbrForce = void 0;\n    var signed = void 0;\n    format = format || '';\n\n    value = value || 0;\n\n    if (~format.indexOf('(')) {\n      negP = true;\n      format = format.replace(/[(|)]/g, '');\n    } else if (~format.indexOf('+') || ~format.indexOf('-')) {\n      signed = ~format.indexOf('+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;\n      format = format.replace(/[+|-]/g, '');\n    }\n    if (~format.indexOf('a')) {\n      abbrForce = format.match(/a(k|m|b|t)?/);\n\n      abbrForce = abbrForce ? abbrForce[1] : false;\n\n      if (~format.indexOf(' a')) abbr = ' ';\n      format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');\n\n      if (abs >= TRILLION && !abbrForce || abbrForce === 't') {\n        abbr += options.abbrLabel.tr;\n        value = value / TRILLION;\n      } else if (abs < TRILLION && abs >= BILLION && !abbrForce || abbrForce === 'b') {\n        abbr += options.abbrLabel.bi;\n        value = value / BILLION;\n      } else if (abs < BILLION && abs >= MILLION && !abbrForce || abbrForce === 'm') {\n        abbr += options.abbrLabel.mi;\n        value = value / MILLION;\n      } else if (abs < MILLION && abs >= THOUSAND && !abbrForce || abbrForce === 'k') {\n        abbr += options.abbrLabel.th;\n        value = value / THOUSAND;\n      }\n    }\n    if (~format.indexOf('[.]')) {\n      optDec = true;\n      format = format.replace('[.]', '.');\n    }\n    var int = value.toString().split('.')[0];\n    var precision = format.split('.')[1];\n    var thousands = format.indexOf(',');\n    var leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;\n\n    if (precision) {\n      if (~precision.indexOf('[')) {\n        precision = precision.replace(']', '');\n        precision = precision.split('[');\n        decimal = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);\n      } else {\n        decimal = toFixed(value, precision.length, roundingFunction);\n      }\n\n      int = decimal.split('.')[0];\n      decimal = ~decimal.indexOf('.') ? '.' + decimal.split('.')[1] : '';\n      if (optDec && +decimal.slice(1) === 0) decimal = '';\n    } else {\n      int = toFixed(value, 0, roundingFunction);\n    }\n    if (abbr && !abbrForce && +int >= 1000 && abbr !== ABBR.trillion) {\n      int = '' + +int / 1000;\n      abbr = ABBR.million;\n    }\n    if (~int.indexOf('-')) {\n      int = int.slice(1);\n      neg = true;\n    }\n    if (int.length < leadingCount) {\n      for (var i = leadingCount - int.length; i > 0; i--) {\n        int = '0' + int;\n      }\n    }\n\n    if (thousands > -1) {\n      int = int.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + ',');\n    }\n\n    if (!format.indexOf('.')) int = '';\n\n    var output = int + decimal + (abbr || '');\n\n    if (negP) {\n      output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');\n    } else {\n      if (signed >= 0) {\n        output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');\n      } else if (neg) {\n        output = '-' + output;\n      }\n    }\n\n    return output;\n  }\n\n  function extend(target, sub) {\n    Object.keys(sub).forEach(function (key) {\n      target[key] = sub[key];\n    });\n  }\n\n  var numerifyPercent = {\n    regexp: /%/,\n    format: function format(value, formatType, roundingFunction, numerify) {\n      var space = ~formatType.indexOf(' %') ? ' ' : '';\n      var output = void 0;\n\n      if (numerify.options.scalePercentBy100) value = value * 100;\n\n      formatType = formatType.replace(/\\s?%/, '');\n\n      output = numerify._numberToFormat(value, formatType, roundingFunction);\n\n      if (~output.indexOf(')')) {\n        output = output.split('');\n        output.splice(-1, 0, space + '%');\n        output = output.join('');\n      } else {\n        output = output + space + '%';\n      }\n\n      return output;\n    }\n  };\n\n  var options = {};\n  var formats = {};\n\n  extend(options, DEFAULT_OPTIONS);\n\n  function format(value, formatType, roundingFunction) {\n    formatType = formatType || options.defaultFormat;\n    roundingFunction = roundingFunction || Math.round;\n    var output = void 0;\n    var formatFunction = void 0;\n\n    if (value === 0 && options.zeroFormat !== null) {\n      output = options.zeroFormat;\n    } else if (value === null && options.nullFormat !== null) {\n      output = options.nullFormat;\n    } else {\n      for (var kind in formats) {\n        if (formats[kind] && formatType.match(formats[kind].regexp)) {\n          formatFunction = formats[kind].format;\n          break;\n        }\n      }\n      formatFunction = formatFunction || numberToFormat.bind(null, options);\n      output = formatFunction(value, formatType, roundingFunction, numerify);\n    }\n\n    return output;\n  }\n\n  function numerify(input, formatType, roundingFunction) {\n    var value = void 0;\n\n    if (input === 0 || typeof input === 'undefined') {\n      value = 0;\n    } else if (input === null || numIsNaN(input)) {\n      value = null;\n    } else if (typeof input === 'string') {\n      if (options.zeroFormat && input === options.zeroFormat) {\n        value = 0;\n      } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {\n        value = null;\n      } else {\n        value = +input;\n      }\n    } else {\n      value = +input || null;\n    }\n\n    return format(value, formatType, roundingFunction);\n  }\n\n  numerify.options = options;\n  numerify._numberToFormat = numberToFormat.bind(null, options);\n  numerify.register = function (name, format) {\n    formats[name] = format;\n  };\n  numerify.unregister = function (name) {\n    formats[name] = null;\n  };\n  numerify.setOptions = function (opts) {\n    extend(options, opts);\n  };\n  numerify.reset = function () {\n    extend(options, DEFAULT_OPTIONS);\n  };\n\n  numerify.register('percentage', numerifyPercent);\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  var defineProperty = function (obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  };\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var toArray = function (arr) {\n    return Array.isArray(arr) ? arr : Array.from(arr);\n  };\n\n  function debounce(fn, delay) {\n    var timer = null;\n    return function () {\n      var self = this;\n      var args = arguments;\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        fn.apply(self, args);\n      }, delay);\n    };\n  }\n\n  function set$1(target, path, value) {\n    if (!path) return;\n    var targetTemp = target;\n    var pathArr = path.split('.');\n    pathArr.forEach(function (item, index) {\n      if (index === pathArr.length - 1) {\n        targetTemp[item] = value;\n      } else {\n        if (!targetTemp[item]) targetTemp[item] = {};\n        targetTemp = targetTemp[item];\n      }\n    });\n  }\n\n  function get$1(target, path, defaultValue) {\n    if (!path) return target;\n    var pathArr = path.split('.');\n    var targetTemp = target;\n    pathArr.some(function (item, index) {\n      if (targetTemp[item] === undefined) {\n        targetTemp = defaultValue;\n        return true;\n      } else {\n        targetTemp = targetTemp[item];\n      }\n    });\n    return targetTemp;\n  }\n\n  var _typeof$1 = typeof Symbol === \"function\" && _typeof(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n  };\n\n  function getType(v) {\n    return Object.prototype.toString.call(v);\n  }\n\n  function getTypeof(v) {\n    return typeof v === 'undefined' ? 'undefined' : _typeof$1(v);\n  }\n\n  function isObject(v) {\n    return getType(v) === '[object Object]';\n  }\n\n  function isArray(v) {\n    return getType(v) === '[object Array]';\n  }\n\n  function isFunction(v) {\n    return getType(v) === '[object Function]';\n  }\n\n  function cloneDeep(v) {\n    return JSON.parse(JSON.stringify(v));\n  }\n\n  function camelToKebab(s) {\n    return s.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n  }\n\n  function hasOwn(source, target) {\n    return Object.prototype.hasOwnProperty.call(source, target);\n  }\n\n  function isEqual(alice, bob) {\n    if (alice === bob) return true;\n    if (alice === null || bob === null || getTypeof(alice) !== 'object' || getTypeof(bob) !== 'object') {\n      return alice === bob;\n    }\n\n    for (var key in alice) {\n      if (!hasOwn(alice, key)) continue;\n      var aliceValue = alice[key];\n      var bobValue = bob[key];\n      var aliceType = getTypeof(aliceValue);\n\n      if (getTypeof(bobValue) === 'undefined') {\n        return false;\n      } else if (aliceType === 'object') {\n        if (!isEqual(aliceValue, bobValue)) return false;\n      } else if (aliceValue !== bobValue) {\n        return false;\n      }\n    }\n    for (var _key in bob) {\n      if (!hasOwn(bob, _key)) continue;\n      if (getTypeof(alice)[_key] === 'undefined') return false;\n    }\n\n    return true;\n  }\n\n  var getFormated = function getFormated(val, type, digit) {\n    var defaultVal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-';\n\n    if (isNaN(val)) return defaultVal;\n    if (!type) return val;\n    if (isFunction(type)) return type(val, numerify);\n\n    digit = isNaN(digit) ? 0 : ++digit;\n    var digitStr = '.[' + new Array(digit).join(0) + ']';\n    var formatter = type;\n    switch (type) {\n      case 'KMB':\n        formatter = digit ? '0,0' + digitStr + 'a' : '0,0a';\n        break;\n      case 'normal':\n        formatter = digit ? '0,0' + digitStr : '0,0';\n        break;\n      case 'percent':\n        formatter = digit ? '0,0' + digitStr + '%' : '0,0.[00]%';\n        break;\n    }\n    return numerify(val, formatter);\n  };\n\n  var getStackMap = function getStackMap(stack) {\n    var stackMap = {};\n    Object.keys(stack).forEach(function (item) {\n      stack[item].forEach(function (name) {\n        stackMap[name] = item;\n      });\n    });\n    return stackMap;\n  };\n\n  var $get = function $get(url) {\n    return new Promise(function (resolve, reject) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url);\n      xhr.send(null);\n      xhr.onload = function () {\n        resolve(JSON.parse(xhr.responseText));\n      };\n      xhr.onerror = function () {\n        reject(JSON.parse(xhr.responseText));\n      };\n    });\n  };\n\n  var mapPromise = {};\n\n  var getMapJSON = function getMapJSON(_ref) {\n    var position = _ref.position,\n        positionJsonLink = _ref.positionJsonLink,\n        beforeRegisterMapOnce = _ref.beforeRegisterMapOnce,\n        mapURLProfix = _ref.mapURLProfix;\n\n    var link = positionJsonLink || '' + mapURLProfix + position + '.json';\n    if (!mapPromise[link]) {\n      mapPromise[link] = $get(link).then(function (res) {\n        if (beforeRegisterMapOnce) res = beforeRegisterMapOnce(res);\n        return res;\n      });\n    }\n    return mapPromise[link];\n  };\n\n  var bmapPromise = null;\n  var amapPromise = null;\n\n  var getBmap = function getBmap(key, v) {\n    if (!bmapPromise) {\n      bmapPromise = new Promise(function (resolve, reject) {\n        var callbackName = 'bmap' + Date.now();\n        window[callbackName] = resolve;\n        var script = document.createElement('script');\n        script.src = ['https://api.map.baidu.com/api?v=' + (v || '2.0'), 'ak=' + key, 'callback=' + callbackName].join('&');\n\n        document.body.appendChild(script);\n      });\n    }\n    return bmapPromise;\n  };\n\n  var getAmap = function getAmap(key, v) {\n    if (!amapPromise) {\n      amapPromise = new Promise(function (resolve, reject) {\n        var callbackName = 'amap' + Date.now();\n        window[callbackName] = resolve;\n        var script = document.createElement('script');\n        script.src = ['https://webapi.amap.com/maps?v=' + (v || '1.4.3'), 'key=' + key, 'callback=' + callbackName].join('&');\n\n        document.body.appendChild(script);\n      });\n    }\n    return amapPromise;\n  };\n\n  function setArrayValue(arr, index, value) {\n    if (arr[index] !== undefined) {\n      arr[index].push(value);\n    } else {\n      arr[index] = [value];\n    }\n  }\n\n  // default opacity of bar while dim-axis type is 'value'\n  var VALUE_AXIS_OPACITY = 0.5;\n\n  function getBarDimAxis(args) {\n    var innerRows = args.innerRows,\n        dimAxisName = args.dimAxisName,\n        dimension = args.dimension,\n        axisVisible = args.axisVisible,\n        dimAxisType = args.dimAxisType,\n        dims = args.dims;\n\n    return dimension.map(function (item) {\n      return {\n        type: 'category',\n        name: dimAxisName,\n        nameLocation: 'middle',\n        nameGap: 22,\n        data: dimAxisType === 'value' ? getValueAxisData(dims) : innerRows.map(function (row) {\n          return row[item];\n        }),\n        axisLabel: {\n          formatter: function formatter(v) {\n            return String(v);\n          }\n        },\n        show: axisVisible\n      };\n    });\n  }\n\n  function getValueAxisData(dims) {\n    var max = Math.max.apply(null, dims);\n    var min = Math.min.apply(null, dims);\n    var result = [];\n    for (var i = min; i <= max; i++) {\n      result.push(i);\n    }\n    return result;\n  }\n\n  function getBarMeaAxis(args) {\n    var meaAxisName = args.meaAxisName,\n        meaAxisType = args.meaAxisType,\n        axisVisible = args.axisVisible,\n        digit = args.digit,\n        scale = args.scale,\n        min = args.min,\n        max = args.max;\n\n    var meaAxisBase = {\n      type: 'value',\n      axisTick: {\n        show: false\n      },\n      show: axisVisible\n    };\n    var meaAxis = [];\n\n    var _loop = function _loop(i) {\n      if (meaAxisType[i]) {\n        meaAxis[i] = _extends({}, meaAxisBase, {\n          axisLabel: {\n            formatter: function formatter(val) {\n              return getFormated(val, meaAxisType[i], digit);\n            }\n          }\n        });\n      } else {\n        meaAxis[i] = _extends({}, meaAxisBase);\n      }\n      meaAxis[i].name = meaAxisName[i] || '';\n      meaAxis[i].scale = scale[i] || false;\n      meaAxis[i].min = min[i] || null;\n      meaAxis[i].max = max[i] || null;\n    };\n\n    for (var i = 0; i < 2; i++) {\n      _loop(i);\n    }\n\n    return meaAxis;\n  }\n\n  function getBarTooltip(args) {\n    var axisSite = args.axisSite,\n        isHistogram = args.isHistogram,\n        meaAxisType = args.meaAxisType,\n        digit = args.digit,\n        labelMap = args.labelMap;\n\n    var secondAxis = isHistogram ? axisSite.right || [] : axisSite.top || [];\n    if (labelMap) {\n      secondAxis = secondAxis.map(function (item) {\n        return labelMap[item] === undefined ? item : labelMap[item];\n      });\n    }\n    return {\n      trigger: 'axis',\n      formatter: function formatter(items) {\n        var tpl = [];\n        tpl.push(items[0].name + '<br>');\n        items.forEach(function (item) {\n          var seriesName = item.seriesName;\n          var type = ~secondAxis.indexOf(seriesName) ? meaAxisType[1] : meaAxisType[0];\n          tpl.push(itemPoint(item.color));\n          tpl.push(seriesName + ': ');\n          tpl.push(getFormated(item.value, type, digit));\n          tpl.push('<br>');\n        });\n\n        return tpl.join('');\n      }\n    };\n  }\n\n  function getValueData(seriesTemp, dims) {\n    var max = Math.max.apply(null, dims);\n    var min = Math.min.apply(null, dims);\n    var result = [];\n    for (var i = min; i <= max; i++) {\n      var index = dims.indexOf(i);\n      if (~index) {\n        result.push(seriesTemp[index]);\n      } else {\n        result.push(null);\n      }\n    }\n    return result;\n  }\n\n  function getBarSeries(args) {\n    var innerRows = args.innerRows,\n        metrics = args.metrics,\n        stack = args.stack,\n        axisSite = args.axisSite,\n        isHistogram = args.isHistogram,\n        labelMap = args.labelMap,\n        itemStyle = args.itemStyle,\n        label = args.label,\n        _args$showLine = args.showLine,\n        showLine = _args$showLine === undefined ? [] : _args$showLine,\n        dimAxisType = args.dimAxisType,\n        barGap = args.barGap,\n        opacity = args.opacity,\n        dims = args.dims;\n\n    var series = [];\n    var seriesTemp = {};\n    var secondAxis = isHistogram ? axisSite.right || [] : axisSite.top || [];\n    var secondDimAxisIndex = isHistogram ? 'yAxisIndex' : 'xAxisIndex';\n    var stackMap = stack && getStackMap(stack);\n    metrics.forEach(function (item) {\n      seriesTemp[item] = [];\n    });\n    innerRows.forEach(function (row) {\n      metrics.forEach(function (item) {\n        seriesTemp[item].push(row[item]);\n      });\n    });\n    series = Object.keys(seriesTemp).map(function (item, index) {\n      var data = dimAxisType === 'value' ? getValueData(seriesTemp[item], dims) : seriesTemp[item];\n      var seriesItem = defineProperty({\n        name: labelMap[item] != null ? labelMap[item] : item,\n        type: ~showLine.indexOf(item) ? 'line' : 'bar',\n        data: data\n      }, secondDimAxisIndex, ~secondAxis.indexOf(item) ? '1' : '0');\n\n      if (stack && stackMap[item]) seriesItem.stack = stackMap[item];\n\n      if (label) seriesItem.label = label;\n      if (itemStyle) seriesItem.itemStyle = itemStyle;\n\n      var itemOpacity = opacity || get$1(seriesItem, 'itemStyle.normal.opacity');\n      if (dimAxisType === 'value') {\n        seriesItem.barGap = barGap;\n        seriesItem.barCategoryGap = '1%';\n        if (itemOpacity == null) itemOpacity = VALUE_AXIS_OPACITY;\n      }\n\n      if (itemOpacity != null) {\n        set$1(seriesItem, 'itemStyle.normal.opacity', itemOpacity);\n      }\n\n      return seriesItem;\n    });\n\n    return series.length ? series : false;\n  }\n\n  function getLegend(args) {\n    var metrics = args.metrics,\n        labelMap = args.labelMap,\n        legendName = args.legendName;\n\n    if (!legendName && !labelMap) return { data: metrics };\n    var data = labelMap ? metrics.map(function (item) {\n      return labelMap[item] == null ? item : labelMap[item];\n    }) : metrics;\n    return {\n      data: data,\n      formatter: function formatter(name) {\n        return legendName[name] != null ? legendName[name] : name;\n      }\n    };\n  }\n\n  function getDims(rows, dimension) {\n    return rows.map(function (row) {\n      return row[dimension[0]];\n    });\n  }\n\n  var bar$1 = function bar$$1(columns, rows, settings, extra) {\n    var innerRows = cloneDeep(rows);\n    var _settings$axisSite = settings.axisSite,\n        axisSite = _settings$axisSite === undefined ? {} : _settings$axisSite,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? [columns[0]] : _settings$dimension,\n        _settings$stack = settings.stack,\n        stack = _settings$stack === undefined ? {} : _settings$stack,\n        _settings$axisVisible = settings.axisVisible,\n        axisVisible = _settings$axisVisible === undefined ? true : _settings$axisVisible,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        _settings$dataOrder = settings.dataOrder,\n        dataOrder = _settings$dataOrder === undefined ? false : _settings$dataOrder,\n        _settings$scale = settings.scale,\n        scale = _settings$scale === undefined ? [false, false] : _settings$scale,\n        _settings$min = settings.min,\n        min = _settings$min === undefined ? [null, null] : _settings$min,\n        _settings$max = settings.max,\n        max = _settings$max === undefined ? [null, null] : _settings$max,\n        _settings$legendName = settings.legendName,\n        legendName = _settings$legendName === undefined ? {} : _settings$legendName,\n        _settings$labelMap = settings.labelMap,\n        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,\n        label = settings.label,\n        itemStyle = settings.itemStyle,\n        showLine = settings.showLine,\n        _settings$barGap = settings.barGap,\n        barGap = _settings$barGap === undefined ? '-100%' : _settings$barGap,\n        opacity = settings.opacity;\n    var tooltipVisible = extra.tooltipVisible,\n        legendVisible = extra.legendVisible;\n\n    var metrics = columns.slice();\n    if (axisSite.top && axisSite.bottom) {\n      metrics = axisSite.top.concat(axisSite.bottom);\n    } else if (axisSite.bottom && !axisSite.right) {\n      metrics = axisSite.bottom;\n    } else if (settings.metrics) {\n      metrics = settings.metrics;\n    } else {\n      metrics.splice(columns.indexOf(dimension[0]), 1);\n    }\n    var meaAxisType = settings.xAxisType || ['normal', 'normal'];\n    var dimAxisType = settings.yAxisType || 'category';\n    var meaAxisName = settings.xAxisName || [];\n    var dimAxisName = settings.yAxisName || '';\n    var isHistogram = false;\n\n    if (dataOrder) {\n      var _label = dataOrder.label,\n          order = dataOrder.order;\n\n      if (!_label || !order) {\n        console.warn('Need to provide name and order parameters');\n      } else {\n        innerRows.sort(function (a, b) {\n          if (order === 'desc') {\n            return a[_label] - b[_label];\n          } else {\n            return b[_label] - a[_label];\n          }\n        });\n      }\n    }\n    var dims = getDims(innerRows, dimension);\n\n    var legend$$1 = legendVisible && getLegend({ metrics: metrics, labelMap: labelMap, legendName: legendName });\n    var yAxis = getBarDimAxis({\n      innerRows: innerRows,\n      dimAxisName: dimAxisName,\n      dimension: dimension,\n      axisVisible: axisVisible,\n      dimAxisType: dimAxisType,\n      dims: dims\n    });\n    var xAxis = getBarMeaAxis({\n      meaAxisName: meaAxisName,\n      meaAxisType: meaAxisType,\n      axisVisible: axisVisible,\n      digit: digit,\n      scale: scale,\n      min: min,\n      max: max\n    });\n    var series = getBarSeries({\n      innerRows: innerRows,\n      metrics: metrics,\n      stack: stack,\n      axisSite: axisSite,\n      isHistogram: isHistogram,\n      labelMap: labelMap,\n      itemStyle: itemStyle,\n      label: label,\n      showLine: showLine,\n      dimAxisType: dimAxisType,\n      dimension: dimension,\n      barGap: barGap,\n      opacity: opacity,\n      dims: dims\n    });\n    var tooltipParams = { axisSite: axisSite, isHistogram: isHistogram, meaAxisType: meaAxisType, digit: digit, labelMap: labelMap };\n    var tooltip$$1 = tooltipVisible && getBarTooltip(tooltipParams);\n    var options = { legend: legend$$1, yAxis: yAxis, series: series, xAxis: xAxis, tooltip: tooltip$$1 };\n    return options;\n  };\n\n  var histogram = function histogram(columns, rows, settings, status) {\n    var innerRows = cloneDeep(rows);\n    var _settings$axisSite2 = settings.axisSite,\n        axisSite = _settings$axisSite2 === undefined ? {} : _settings$axisSite2,\n        _settings$dimension2 = settings.dimension,\n        dimension = _settings$dimension2 === undefined ? [columns[0]] : _settings$dimension2,\n        _settings$stack2 = settings.stack,\n        stack = _settings$stack2 === undefined ? {} : _settings$stack2,\n        _settings$axisVisible2 = settings.axisVisible,\n        axisVisible = _settings$axisVisible2 === undefined ? true : _settings$axisVisible2,\n        _settings$digit2 = settings.digit,\n        digit = _settings$digit2 === undefined ? 2 : _settings$digit2,\n        _settings$dataOrder2 = settings.dataOrder,\n        dataOrder = _settings$dataOrder2 === undefined ? false : _settings$dataOrder2,\n        _settings$scale2 = settings.scale,\n        scale = _settings$scale2 === undefined ? [false, false] : _settings$scale2,\n        _settings$min2 = settings.min,\n        min = _settings$min2 === undefined ? [null, null] : _settings$min2,\n        _settings$max2 = settings.max,\n        max = _settings$max2 === undefined ? [null, null] : _settings$max2,\n        _settings$labelMap2 = settings.labelMap,\n        labelMap = _settings$labelMap2 === undefined ? {} : _settings$labelMap2,\n        _settings$legendName2 = settings.legendName,\n        legendName = _settings$legendName2 === undefined ? {} : _settings$legendName2,\n        label = settings.label,\n        itemStyle = settings.itemStyle,\n        showLine = settings.showLine,\n        _settings$barGap2 = settings.barGap,\n        barGap = _settings$barGap2 === undefined ? '-100%' : _settings$barGap2,\n        opacity = settings.opacity;\n\n\n    if (dataOrder) {\n      var _label2 = dataOrder.label,\n          order = dataOrder.order;\n\n      if (!_label2 || !order) {\n        console.warn('Need to provide name and order parameters');\n      } else {\n        innerRows.sort(function (a, b) {\n          if (order === 'desc') {\n            return a[_label2] - b[_label2];\n          } else {\n            return b[_label2] - a[_label2];\n          }\n        });\n      }\n    }\n\n    var tooltipVisible = status.tooltipVisible,\n        legendVisible = status.legendVisible;\n\n    var metrics = columns.slice();\n    if (axisSite.left && axisSite.right) {\n      metrics = axisSite.left.concat(axisSite.right);\n    } else if (axisSite.left && !axisSite.right) {\n      metrics = axisSite.left;\n    } else if (settings.metrics) {\n      metrics = settings.metrics;\n    } else {\n      metrics.splice(columns.indexOf(dimension[0]), 1);\n    }\n    var meaAxisType = settings.yAxisType || ['normal', 'normal'];\n    var dimAxisType = settings.xAxisType || 'category';\n    var meaAxisName = settings.yAxisName || [];\n    var dimAxisName = settings.xAxisName || '';\n    var isHistogram = true;\n    var dims = getDims(innerRows, dimension);\n\n    var legend$$1 = legendVisible && getLegend({ metrics: metrics, labelMap: labelMap, legendName: legendName });\n    var xAxis = getBarDimAxis({\n      innerRows: innerRows,\n      dimAxisName: dimAxisName,\n      dimension: dimension,\n      axisVisible: axisVisible,\n      dimAxisType: dimAxisType,\n      dims: dims\n    });\n    var yAxis = getBarMeaAxis({\n      meaAxisName: meaAxisName,\n      meaAxisType: meaAxisType,\n      axisVisible: axisVisible,\n      digit: digit,\n      scale: scale,\n      min: min,\n      max: max\n    });\n    var series = getBarSeries({\n      innerRows: innerRows,\n      metrics: metrics,\n      stack: stack,\n      axisSite: axisSite,\n      isHistogram: isHistogram,\n      labelMap: labelMap,\n      itemStyle: itemStyle,\n      label: label,\n      showLine: showLine,\n      dimAxisType: dimAxisType,\n      dimension: dimension,\n      barGap: barGap,\n      opacity: opacity,\n      dims: dims\n    });\n    var tooltipParams = { axisSite: axisSite, isHistogram: isHistogram, meaAxisType: meaAxisType, digit: digit, labelMap: labelMap };\n    var tooltip$$1 = tooltipVisible && getBarTooltip(tooltipParams);\n    var options = { legend: legend$$1, yAxis: yAxis, series: series, xAxis: xAxis, tooltip: tooltip$$1 };\n    return options;\n  };\n\n  var Loading = { render: function render() {\n      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: \"v-charts-component-loading\" }, [_c('div', { staticClass: \"loader\" }, [_c('div', { staticClass: \"loading-spinner\" }, [_c('svg', { staticClass: \"circular\", attrs: { \"viewBox\": \"25 25 50 50\" } }, [_c('circle', { staticClass: \"path\", attrs: { \"cx\": \"50\", \"cy\": \"50\", \"r\": \"20\", \"fill\": \"none\" } })])])])]);\n    }, staticRenderFns: []\n  };\n\n  var DataEmpty = { render: function render() {\n      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: \"v-charts-data-empty\" }, [_vm._v(\"  \")]);\n    }, staticRenderFns: []\n  };\n\n  function setExtend (options, extend) {\n    Object.keys(extend).forEach(function (attr) {\n      var value = extend[attr];\n      if (~attr.indexOf('.')) {\n        // eg: a.b.c a.1.b\n        set$1(options, attr, value);\n      } else if (typeof value === 'function') {\n        // get callback value\n        options[attr] = value(options[attr]);\n      } else {\n        // mixin extend value\n        if (isArray(options[attr]) && isObject(options[attr][0])) {\n          // eg: [{ xx: 1 }, { xx: 2 }]\n          options[attr].forEach(function (option, index) {\n            options[attr][index] = _extends({}, option, value);\n          });\n        } else if (isObject(options[attr])) {\n          // eg: { xx: 1, yy: 2 }\n          options[attr] = _extends({}, options[attr], value);\n        } else {\n          options[attr] = value;\n        }\n      }\n    });\n  }\n\n  function setMark (seriesItem, marks) {\n    Object.keys(marks).forEach(function (key) {\n      if (marks[key]) seriesItem[key] = marks[key];\n    });\n  }\n\n  function setAnimation (options, animation) {\n    Object.keys(animation).forEach(function (key) {\n      options[key] = animation[key];\n    });\n  }\n\n  var Core = {\n    render: function render(h) {\n      return h('div', {\n        class: [camelToKebab(this.$options.name || this.$options._componentTag)],\n        style: this.canvasStyle\n      }, [h('div', {\n        style: this.canvasStyle,\n        class: { 'v-charts-mask-status': this.dataEmpty || this.loading },\n        ref: 'canvas'\n      }), h(DataEmpty, {\n        style: { display: this.dataEmpty ? '' : 'none' }\n      }), h(Loading, {\n        style: { display: this.loading ? '' : 'none' }\n      }), this.$slots.default]);\n    },\n\n\n    props: {\n      data: { type: [Object, Array], default: function _default() {\n          return {};\n        }\n      },\n      settings: { type: Object, default: function _default() {\n          return {};\n        }\n      },\n      width: { type: String, default: 'auto' },\n      height: { type: String, default: '400px' },\n      beforeConfig: { type: Function },\n      afterConfig: { type: Function },\n      afterSetOption: { type: Function },\n      afterSetOptionOnce: { type: Function },\n      events: { type: Object },\n      grid: { type: [Object, Array] },\n      colors: { type: Array },\n      tooltipVisible: { type: Boolean, default: true },\n      legendVisible: { type: Boolean, default: true },\n      legendPosition: { type: String },\n      markLine: { type: Object },\n      markArea: { type: Object },\n      markPoint: { type: Object },\n      visualMap: { type: [Object, Array] },\n      dataZoom: { type: [Object, Array] },\n      toolbox: { type: [Object, Array] },\n      initOptions: { type: Object, default: function _default() {\n          return {};\n        }\n      },\n      title: [Object, Array],\n      legend: [Object, Array],\n      xAxis: [Object, Array],\n      yAxis: [Object, Array],\n      radar: Object,\n      tooltip: Object,\n      axisPointer: [Object, Array],\n      brush: [Object, Array],\n      geo: [Object, Array],\n      timeline: [Object, Array],\n      graphic: [Object, Array],\n      series: [Object, Array],\n      backgroundColor: [Object, String],\n      textStyle: [Object, Array],\n      animation: Object,\n      theme: Object,\n      themeName: String,\n      loading: Boolean,\n      dataEmpty: Boolean,\n      extend: Object,\n      judgeWidth: { type: Boolean, default: false },\n      widthChangeDelay: { type: Number, default: 300 },\n      tooltipFormatter: { type: Function },\n      resizeable: { type: Boolean, default: true },\n      resizeDelay: { type: Number, default: 200 },\n      changeDelay: { type: Number, default: 0 },\n      setOptionOpts: { type: [Boolean, Object], default: true },\n      cancelResizeCheck: Boolean,\n      notSetUnchange: Array,\n      log: Boolean\n    },\n\n    watch: {\n      data: {\n        deep: true,\n        handler: function handler(v) {\n          if (v) {\n            this.changeHandler();\n          }\n        }\n      },\n\n      settings: {\n        deep: true,\n        handler: function handler(v) {\n          if (v.type && this.chartLib) this.chartHandler = this.chartLib[v.type];\n          this.changeHandler();\n        }\n      },\n\n      width: 'nextTickResize',\n      height: 'nextTickResize',\n\n      events: {\n        deep: true,\n        handler: 'createEventProxy'\n      },\n\n      theme: {\n        deep: true,\n        handler: 'themeChange'\n      },\n\n      themeName: 'themeChange',\n\n      resizeable: 'resizeableHandler'\n    },\n\n    computed: {\n      canvasStyle: function canvasStyle() {\n        return {\n          width: this.width,\n          height: this.height,\n          position: 'relative'\n        };\n      },\n      chartColor: function chartColor() {\n        return this.colors || this.theme && this.theme.color || DEFAULT_COLORS;\n      }\n    },\n\n    methods: {\n      dataHandler: function dataHandler() {\n        if (!this.chartHandler) return;\n        var data = this.data;\n        var _data = data,\n            _data$columns = _data.columns,\n            columns = _data$columns === undefined ? [] : _data$columns,\n            _data$rows = _data.rows,\n            rows = _data$rows === undefined ? [] : _data$rows;\n\n        var extra = {\n          tooltipVisible: this.tooltipVisible,\n          legendVisible: this.legendVisible,\n          echarts: this.echarts,\n          color: this.chartColor,\n          tooltipFormatter: this.tooltipFormatter,\n          _once: this._once\n        };\n        if (this.beforeConfig) data = this.beforeConfig(data);\n\n        var options = this.chartHandler(columns, rows, this.settings, extra);\n        if (options) {\n          if (typeof options.then === 'function') {\n            options.then(this.optionsHandler);\n          } else {\n            this.optionsHandler(options);\n          }\n        }\n      },\n      nextTickResize: function nextTickResize() {\n        this.$nextTick(this.resize);\n      },\n      resize: function resize() {\n        if (!this.cancelResizeCheck) {\n          if (this.$el && this.$el.clientWidth && this.$el.clientHeight) {\n            this.echartsResize();\n          }\n        } else {\n          this.echartsResize();\n        }\n      },\n      echartsResize: function echartsResize() {\n        this.echarts && this.echarts.resize();\n      },\n      optionsHandler: function optionsHandler(options) {\n        var _this = this;\n\n        // legend\n        if (this.legendPosition && options.legend) {\n          options.legend[this.legendPosition] = 10;\n          if (~['left', 'right'].indexOf(this.legendPosition)) {\n            options.legend.top = 'middle';\n            options.legend.orient = 'vertical';\n          }\n        }\n        // color\n        options.color = this.chartColor;\n        // echarts self settings\n        ECHARTS_SETTINGS.forEach(function (setting) {\n          if (_this[setting]) options[setting] = _this[setting];\n        });\n        // animation\n        if (this.animation) setAnimation(options, this.animation);\n        // marks\n        if (this.markArea || this.markLine || this.markPoint) {\n          var marks = {\n            markArea: this.markArea,\n            markLine: this.markLine,\n            markPoint: this.markPoint\n          };\n          var series = options.series;\n          if (isArray(series)) {\n            series.forEach(function (item) {\n              setMark(item, marks);\n            });\n          } else if (isObject(series)) {\n            setMark(series, marks);\n          }\n        }\n        // change inited echarts settings\n        if (this.extend) setExtend(options, this.extend);\n        if (this.afterConfig) options = this.afterConfig(options);\n        var setOptionOpts = this.setOptionOpts;\n        // map chart not merge\n        if ((this.settings.bmap || this.settings.amap) && !isObject(setOptionOpts)) {\n          setOptionOpts = false;\n        }\n        // exclude unchange options\n        if (this.notSetUnchange && this.notSetUnchange.length) {\n          this.notSetUnchange.forEach(function (item) {\n            var value = options[item];\n            if (value) {\n              if (isEqual(value, _this._store[item])) {\n                options[item] = undefined;\n              } else {\n                _this._store[item] = cloneDeep(value);\n              }\n            }\n          });\n          if (isObject(setOptionOpts)) {\n            setOptionOpts.notMerge = false;\n          } else {\n            setOptionOpts = false;\n          }\n        }\n        if (this._isDestroyed) return;\n        if (this.log) console.log(options);\n        this.echarts.setOption(options, setOptionOpts);\n        this.$emit('ready', this.echarts, options, echartsLib);\n        if (!this._once['ready-once']) {\n          this._once['ready-once'] = true;\n          this.$emit('ready-once', this.echarts, options, echartsLib);\n        }\n        if (this.judgeWidth) this.judgeWidthHandler(options);\n        if (this.afterSetOption) this.afterSetOption(this.echarts, options, echartsLib);\n        if (this.afterSetOptionOnce && !this._once['afterSetOptionOnce']) {\n          this._once['afterSetOptionOnce'] = true;\n          this.afterSetOptionOnce(this.echarts, options, echartsLib);\n        }\n      },\n      judgeWidthHandler: function judgeWidthHandler(options) {\n        var _this2 = this;\n\n        var widthChangeDelay = this.widthChangeDelay,\n            resize = this.resize;\n\n        if (this.$el.clientWidth || this.$el.clientHeight) {\n          resize();\n        } else {\n          this.$nextTick(function (_) {\n            if (_this2.$el.clientWidth || _this2.$el.clientHeight) {\n              resize();\n            } else {\n              setTimeout(function (_) {\n                resize();\n                if (!_this2.$el.clientWidth || !_this2.$el.clientHeight) {\n                  console.warn(' Can\\'t get dom width or height ');\n                }\n              }, widthChangeDelay);\n            }\n          });\n        }\n      },\n      resizeableHandler: function resizeableHandler(resizeable) {\n        if (resizeable && !this._once.onresize) this.addResizeListener();\n        if (!resizeable && this._once.onresize) this.removeResizeListener();\n      },\n      init: function init() {\n        if (this.echarts) return;\n        var themeName = this.themeName || this.theme || DEFAULT_THEME;\n        this.echarts = echartsLib.init(this.$refs.canvas, themeName, this.initOptions);\n        if (this.data) this.changeHandler();\n        this.createEventProxy();\n        if (this.resizeable) this.addResizeListener();\n      },\n      addResizeListener: function addResizeListener() {\n        window.addEventListener('resize', this.resizeHandler);\n        this._once.onresize = true;\n      },\n      removeResizeListener: function removeResizeListener() {\n        window.removeEventListener('resize', this.resizeHandler);\n        this._once.onresize = false;\n      },\n      addWatchToProps: function addWatchToProps() {\n        var _this3 = this;\n\n        var watchedVariable = this._watchers.map(function (watcher) {\n          return watcher.expression;\n        });\n        Object.keys(this.$props).forEach(function (prop) {\n          if (!~watchedVariable.indexOf(prop) && !~STATIC_PROPS.indexOf(prop)) {\n            var opts = {};\n            if (~['[object Object]', '[object Array]'].indexOf(getType(_this3.$props[prop]))) {\n              opts.deep = true;\n            }\n            _this3.$watch(prop, function () {\n              _this3.changeHandler();\n            }, opts);\n          }\n        });\n      },\n      createEventProxy: function createEventProxy() {\n        var _this4 = this;\n\n        //  on \n        //  events \n        //  events \n        var self = this;\n        var keys = Object.keys(this.events || {});\n        keys.length && keys.forEach(function (ev) {\n          if (_this4.registeredEvents.indexOf(ev) === -1) {\n            _this4.registeredEvents.push(ev);\n            _this4.echarts.on(ev, function (ev) {\n              return function () {\n                if (ev in self.events) {\n                  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                    args[_key] = arguments[_key];\n                  }\n\n                  self.events[ev].apply(null, args);\n                }\n              };\n            }(ev));\n          }\n        });\n      },\n      themeChange: function themeChange(theme) {\n        this.clean();\n        this.echarts = null;\n        this.init();\n      },\n      clean: function clean() {\n        if (this.resizeable) this.removeResizeListener();\n        this.echarts.dispose();\n      }\n    },\n\n    created: function created() {\n      this.echarts = null;\n      this.registeredEvents = [];\n      this._once = {};\n      this._store = {};\n      this.resizeHandler = debounce(this.resize, this.resizeDelay);\n      this.changeHandler = debounce(this.dataHandler, this.changeDelay);\n      this.addWatchToProps();\n    },\n    mounted: function mounted() {\n      this.init();\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.clean();\n    },\n\n\n    _numerify: numerify\n  };\n\n  var VeBar = _extends({}, Core, {\n    name: 'VeBar',\n    data: function data() {\n      this.chartHandler = bar$1;\n      return {};\n    }\n  });\n\n  var VeHistogram = _extends({}, Core, {\n    name: 'VeHistogram',\n    data: function data() {\n      this.chartHandler = histogram;\n      return {};\n    }\n  });\n\n  function getLineXAxis(args) {\n    var dimension = args.dimension,\n        rows = args.rows,\n        xAxisName = args.xAxisName,\n        axisVisible = args.axisVisible,\n        xAxisType = args.xAxisType;\n\n    return dimension.map(function (item, index) {\n      return {\n        type: xAxisType,\n        nameLocation: 'middle',\n        nameGap: 22,\n        name: xAxisName[index] || '',\n        axisTick: { show: true, lineStyle: { color: '#eee' } },\n        data: rows.map(function (row) {\n          return row[item];\n        }),\n        show: axisVisible\n      };\n    });\n  }\n\n  function getLineSeries(args) {\n    var rows = args.rows,\n        axisSite = args.axisSite,\n        metrics = args.metrics,\n        area = args.area,\n        stack = args.stack,\n        nullAddZero = args.nullAddZero,\n        labelMap = args.labelMap,\n        label = args.label,\n        itemStyle = args.itemStyle,\n        lineStyle = args.lineStyle,\n        areaStyle = args.areaStyle,\n        dimension = args.dimension;\n\n    var series = [];\n    var dataTemp = {};\n    var stackMap = stack && getStackMap(stack);\n    metrics.forEach(function (item) {\n      dataTemp[item] = [];\n    });\n    rows.forEach(function (row) {\n      metrics.forEach(function (item) {\n        var value = null;\n        if (row[item] != null) {\n          value = row[item];\n        } else if (nullAddZero) {\n          value = 0;\n        }\n        dataTemp[item].push([row[dimension[0]], value]);\n      });\n    });\n    metrics.forEach(function (item) {\n      var seriesItem = {\n        name: labelMap[item] != null ? labelMap[item] : item,\n        type: 'line',\n        data: dataTemp[item]\n      };\n\n      if (area) seriesItem.areaStyle = { normal: {} };\n      if (axisSite.right) {\n        seriesItem.yAxisIndex = ~axisSite.right.indexOf(item) ? 1 : 0;\n      }\n\n      if (stack && stackMap[item]) seriesItem.stack = stackMap[item];\n\n      if (label) seriesItem.label = label;\n      if (itemStyle) seriesItem.itemStyle = itemStyle;\n      if (lineStyle) seriesItem.lineStyle = lineStyle;\n      if (areaStyle) seriesItem.areaStyle = areaStyle;\n\n      series.push(seriesItem);\n    });\n    return series;\n  }\n\n  function getLineYAxis(args) {\n    var yAxisName = args.yAxisName,\n        yAxisType = args.yAxisType,\n        axisVisible = args.axisVisible,\n        scale = args.scale,\n        min = args.min,\n        max = args.max,\n        digit = args.digit;\n\n    var yAxisBase = {\n      type: 'value',\n      axisTick: {\n        show: false\n      },\n      show: axisVisible\n    };\n    var yAxis = [];\n\n    var _loop = function _loop(i) {\n      if (yAxisType[i]) {\n        yAxis[i] = _extends({}, yAxisBase, {\n          axisLabel: {\n            formatter: function formatter(val) {\n              return getFormated(val, yAxisType[i], digit);\n            }\n          }\n        });\n      } else {\n        yAxis[i] = _extends({}, yAxisBase);\n      }\n      yAxis[i].name = yAxisName[i] || '';\n      yAxis[i].scale = scale[i] || false;\n      yAxis[i].min = min[i] || null;\n      yAxis[i].max = max[i] || null;\n    };\n\n    for (var i = 0; i < 2; i++) {\n      _loop(i);\n    }\n    return yAxis;\n  }\n\n  function getLineTooltip(args) {\n    var axisSite = args.axisSite,\n        yAxisType = args.yAxisType,\n        digit = args.digit,\n        labelMap = args.labelMap,\n        tooltipFormatter = args.tooltipFormatter;\n\n    var rightItems = axisSite.right || [];\n    var rightList = labelMap ? rightItems.map(function (item) {\n      return labelMap[item] === undefined ? item : labelMap[item];\n    }) : rightItems;\n    return {\n      trigger: 'axis',\n      formatter: function formatter(items) {\n        if (tooltipFormatter) {\n          return tooltipFormatter.apply(null, arguments);\n        }\n        var tpl = [];\n        var _items$ = items[0],\n            name = _items$.name,\n            axisValueLabel = _items$.axisValueLabel;\n\n        var title = name || axisValueLabel;\n        tpl.push(title + '<br>');\n        items.forEach(function (_ref) {\n          var seriesName = _ref.seriesName,\n              data = _ref.data,\n              marker = _ref.marker;\n\n          var showData = null;\n          var type = ~rightList.indexOf(seriesName) ? yAxisType[1] : yAxisType[0];\n          var itemData = isArray(data) ? data[1] : data;\n          showData = getFormated(itemData, type, digit);\n          tpl.push(marker);\n          tpl.push(seriesName + ': ' + showData);\n          tpl.push('<br>');\n        });\n        return tpl.join('');\n      }\n    };\n  }\n\n  function getLegend$1(args) {\n    var metrics = args.metrics,\n        legendName = args.legendName,\n        labelMap = args.labelMap;\n\n    if (!legendName && !labelMap) return { data: metrics };\n    var data = labelMap ? metrics.map(function (item) {\n      return labelMap[item] == null ? item : labelMap[item];\n    }) : metrics;\n    return {\n      data: data,\n      formatter: function formatter(name) {\n        return legendName[name] != null ? legendName[name] : name;\n      }\n    };\n  }\n\n  var line$1 = function line$$1(columns, rows, settings, extra) {\n    rows = isArray(rows) ? rows : [];\n    columns = isArray(columns) ? columns : [];\n    var _settings$axisSite = settings.axisSite,\n        axisSite = _settings$axisSite === undefined ? {} : _settings$axisSite,\n        _settings$yAxisType = settings.yAxisType,\n        yAxisType = _settings$yAxisType === undefined ? ['normal', 'normal'] : _settings$yAxisType,\n        _settings$xAxisType = settings.xAxisType,\n        xAxisType = _settings$xAxisType === undefined ? 'category' : _settings$xAxisType,\n        _settings$yAxisName = settings.yAxisName,\n        yAxisName = _settings$yAxisName === undefined ? [] : _settings$yAxisName,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? [columns[0]] : _settings$dimension,\n        _settings$xAxisName = settings.xAxisName,\n        xAxisName = _settings$xAxisName === undefined ? [] : _settings$xAxisName,\n        _settings$axisVisible = settings.axisVisible,\n        axisVisible = _settings$axisVisible === undefined ? true : _settings$axisVisible,\n        area = settings.area,\n        stack = settings.stack,\n        _settings$scale = settings.scale,\n        scale = _settings$scale === undefined ? [false, false] : _settings$scale,\n        _settings$min = settings.min,\n        min = _settings$min === undefined ? [null, null] : _settings$min,\n        _settings$max = settings.max,\n        max = _settings$max === undefined ? [null, null] : _settings$max,\n        _settings$nullAddZero = settings.nullAddZero,\n        nullAddZero = _settings$nullAddZero === undefined ? false : _settings$nullAddZero,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        _settings$legendName = settings.legendName,\n        legendName = _settings$legendName === undefined ? {} : _settings$legendName,\n        _settings$labelMap = settings.labelMap,\n        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,\n        label = settings.label,\n        itemStyle = settings.itemStyle,\n        lineStyle = settings.lineStyle,\n        areaStyle = settings.areaStyle;\n    var tooltipVisible = extra.tooltipVisible,\n        legendVisible = extra.legendVisible,\n        tooltipFormatter = extra.tooltipFormatter;\n\n    var metrics = columns.slice();\n\n    if (axisSite.left && axisSite.right) {\n      metrics = axisSite.left.concat(axisSite.right);\n    } else if (axisSite.left && !axisSite.right) {\n      metrics = axisSite.left;\n    } else if (settings.metrics) {\n      metrics = settings.metrics;\n    } else {\n      metrics.splice(columns.indexOf(dimension[0]), 1);\n    }\n\n    var legend$$1 = legendVisible && getLegend$1({ metrics: metrics, legendName: legendName, labelMap: labelMap });\n    var tooltip$$1 = tooltipVisible && getLineTooltip({\n      axisSite: axisSite,\n      yAxisType: yAxisType,\n      digit: digit,\n      labelMap: labelMap,\n      xAxisType: xAxisType,\n      tooltipFormatter: tooltipFormatter\n    });\n    var xAxis = getLineXAxis({\n      dimension: dimension,\n      rows: rows,\n      xAxisName: xAxisName,\n      axisVisible: axisVisible,\n      xAxisType: xAxisType\n    });\n    var yAxis = getLineYAxis({\n      yAxisName: yAxisName,\n      yAxisType: yAxisType,\n      axisVisible: axisVisible,\n      scale: scale,\n      min: min,\n      max: max,\n      digit: digit\n    });\n    var series = getLineSeries({\n      rows: rows,\n      axisSite: axisSite,\n      metrics: metrics,\n      area: area,\n      stack: stack,\n      nullAddZero: nullAddZero,\n      labelMap: labelMap,\n      label: label,\n      itemStyle: itemStyle,\n      lineStyle: lineStyle,\n      areaStyle: areaStyle,\n      xAxisType: xAxisType,\n      dimension: dimension\n    });\n    var options = { legend: legend$$1, xAxis: xAxis, series: series, yAxis: yAxis, tooltip: tooltip$$1 };\n    return options;\n  };\n\n  var VeLine = _extends({}, Core, {\n    name: 'VeLine',\n    data: function data() {\n      this.chartHandler = line$1;\n      return {};\n    }\n  });\n\n  var pieRadius = 100;\n  var ringRadius = [80, 100];\n  var roseRingRadius = [20, 100];\n  var pieOffsetY = 200;\n\n  function getPieSeries(args) {\n    var innerRows = args.innerRows,\n        dataType = args.dataType,\n        percentShow = args.percentShow,\n        dimension = args.dimension,\n        metrics = args.metrics,\n        radius = args.radius,\n        offsetY = args.offsetY,\n        selectedMode = args.selectedMode,\n        hoverAnimation = args.hoverAnimation,\n        digit = args.digit,\n        roseType = args.roseType,\n        label = args.label,\n        level = args.level,\n        limitShowNum = args.limitShowNum,\n        isRing = args.isRing,\n        labelLine = args.labelLine,\n        itemStyle = args.itemStyle;\n\n\n    var series = [];\n    var levelTemp = {};\n    var rowsTemp = [];\n    if (level) {\n      level.forEach(function (levelItems, index) {\n        levelItems.forEach(function (item) {\n          setArrayValue(levelTemp, item, index);\n        });\n      });\n      innerRows.forEach(function (row) {\n        var itemLevel = levelTemp[row[dimension]];\n        if (itemLevel && itemLevel.length) {\n          itemLevel.forEach(function (levelItem) {\n            setArrayValue(rowsTemp, levelItem, row);\n          });\n        }\n      });\n    } else {\n      rowsTemp.push(innerRows);\n    }\n    var seriesBase = {\n      type: 'pie',\n      selectedMode: selectedMode,\n      hoverAnimation: hoverAnimation,\n      roseType: roseType,\n      center: ['50%', offsetY]\n    };\n    var rowsTempLength = rowsTemp.length;\n    rowsTemp.forEach(function (dataRows, index) {\n      var seriesItem = _extends({ data: [] }, seriesBase);\n      var centerWidth = radius / rowsTempLength;\n      if (!index) {\n        seriesItem.radius = isRing ? radius : centerWidth;\n      } else {\n        var outerWidth = centerWidth + radius / (2 * rowsTempLength) * (2 * index - 1);\n        var innerWidth = outerWidth + radius / (2 * rowsTempLength);\n        seriesItem.radius = [outerWidth, innerWidth];\n      }\n      if (rowsTempLength > 1 && index === 0) {\n        seriesItem.label = {\n          normal: { position: 'inner' }\n        };\n      }\n      if (label) seriesItem.label = label;\n      if (labelLine) seriesItem.labelLine = labelLine;\n      if (itemStyle) seriesItem.itemStyle = itemStyle;\n      if (percentShow) {\n        seriesItem.label = {\n          normal: {\n            show: true,\n            position: rowsTempLength > 1 && index === 0 ? 'inner' : 'outside',\n            formatter: function formatter(item) {\n              var tpl = [];\n              tpl.push(item.name + ':');\n              tpl.push(getFormated(item.value, dataType, digit));\n              tpl.push('(' + item.percent + '%)');\n              return tpl.join(' ');\n            }\n          }\n        };\n      }\n      seriesItem.data = dataRows.map(function (row) {\n        return {\n          name: row[dimension],\n          value: row[metrics]\n        };\n      });\n      series.push(seriesItem);\n    });\n    if (limitShowNum && limitShowNum < series[0].data.length) {\n      var firstData = series[0].data;\n      var remainArr = firstData.slice(limitShowNum, firstData.length);\n      var sum = 0;\n      remainArr.forEach(function (item) {\n        sum += item.value;\n      });\n      series[0].data = firstData.slice(0, limitShowNum);\n      series[0].data.push({ name: '', value: sum });\n    }\n    return series;\n  }\n\n  function getPieLegend(args) {\n    var innerRows = args.innerRows,\n        dimension = args.dimension,\n        legendLimit = args.legendLimit,\n        legendName = args.legendName,\n        level = args.level,\n        limitShowNum = args.limitShowNum;\n\n    var legend$$1 = [];\n    var levelTemp = [];\n    if (level) {\n      level.forEach(function (levelItem) {\n        levelItem.forEach(function (item) {\n          levelTemp.push(item);\n        });\n      });\n      legend$$1 = levelTemp;\n    } else if (limitShowNum && limitShowNum < innerRows.length) {\n      for (var i = 0; i < limitShowNum; i++) {\n        legend$$1.push(innerRows[i][dimension]);\n      }\n      legend$$1.push('');\n    } else {\n      legend$$1 = innerRows.map(function (row) {\n        return row[dimension];\n      });\n    }\n    if (legend$$1.length) {\n      return {\n        data: legend$$1,\n        show: legend$$1.length < legendLimit,\n        formatter: function formatter(name) {\n          return legendName[name] != null ? legendName[name] : name;\n        }\n      };\n    } else {\n      return false;\n    }\n  }\n\n  function getPieTooltip(args) {\n    var dataType = args.dataType,\n        innerRows = args.innerRows,\n        limitShowNum = args.limitShowNum,\n        digit = args.digit,\n        metrics = args.metrics,\n        dimension = args.dimension;\n\n    var sum = 0;\n    var remainArr = innerRows.map(function (row) {\n      sum += row[metrics];\n      return {\n        name: row[dimension],\n        value: row[metrics]\n      };\n    }).slice(limitShowNum, innerRows.length);\n    return {\n      formatter: function formatter(item) {\n        var tpl = [];\n        tpl.push(itemPoint(item.color));\n        if (limitShowNum && item.name === '') {\n          tpl.push(':');\n          remainArr.forEach(function (_ref) {\n            var name = _ref.name,\n                value = _ref.value;\n\n            var percent = getFormated(value / sum, 'percent');\n            tpl.push('<br>' + name + ':');\n            tpl.push(getFormated(value, dataType, digit));\n            tpl.push('(' + percent + ')');\n          });\n        } else {\n          tpl.push(item.name + ':');\n          tpl.push(getFormated(item.value, dataType, digit));\n          tpl.push('(' + item.percent + '%)');\n        }\n        return tpl.join(' ');\n      }\n    };\n  }\n\n  var pie$1 = function pie$$1(columns, rows, settings, extra, isRing) {\n    var innerRows = cloneDeep(rows);\n    var _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,\n        percentShow = settings.percentShow,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$metrics = settings.metrics,\n        metrics = _settings$metrics === undefined ? columns[1] : _settings$metrics,\n        _settings$roseType = settings.roseType,\n        roseType = _settings$roseType === undefined ? false : _settings$roseType,\n        _settings$radius = settings.radius,\n        radius = _settings$radius === undefined ? isRing ? roseType ? roseRingRadius : ringRadius : pieRadius : _settings$radius,\n        _settings$offsetY = settings.offsetY,\n        offsetY = _settings$offsetY === undefined ? pieOffsetY : _settings$offsetY,\n        _settings$legendLimit = settings.legendLimit,\n        legendLimit = _settings$legendLimit === undefined ? 30 : _settings$legendLimit,\n        _settings$selectedMod = settings.selectedMode,\n        selectedMode = _settings$selectedMod === undefined ? false : _settings$selectedMod,\n        _settings$hoverAnimat = settings.hoverAnimation,\n        hoverAnimation = _settings$hoverAnimat === undefined ? true : _settings$hoverAnimat,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        _settings$legendName = settings.legendName,\n        legendName = _settings$legendName === undefined ? {} : _settings$legendName,\n        _settings$label = settings.label,\n        label = _settings$label === undefined ? false : _settings$label,\n        _settings$level = settings.level,\n        level = _settings$level === undefined ? false : _settings$level,\n        _settings$limitShowNu = settings.limitShowNum,\n        limitShowNum = _settings$limitShowNu === undefined ? 0 : _settings$limitShowNu,\n        labelLine = settings.labelLine,\n        itemStyle = settings.itemStyle;\n    var tooltipVisible = extra.tooltipVisible,\n        legendVisible = extra.legendVisible;\n\n    if (limitShowNum) innerRows.sort(function (a, b) {\n      return b[metrics] - a[metrics];\n    });\n    var seriesParams = {\n      innerRows: innerRows,\n      dataType: dataType,\n      percentShow: percentShow,\n      dimension: dimension,\n      metrics: metrics,\n      radius: radius,\n      offsetY: offsetY,\n      selectedMode: selectedMode,\n      hoverAnimation: hoverAnimation,\n      digit: digit,\n      roseType: roseType,\n      label: label,\n      level: level,\n      legendName: legendName,\n      limitShowNum: limitShowNum,\n      isRing: isRing,\n      labelLine: labelLine,\n      itemStyle: itemStyle\n    };\n    var series = getPieSeries(seriesParams);\n    var legendParams = {\n      innerRows: innerRows,\n      dimension: dimension,\n      legendLimit: legendLimit,\n      legendName: legendName,\n      level: level,\n      limitShowNum: limitShowNum\n    };\n    var legend$$1 = legendVisible && getPieLegend(legendParams);\n    var tooltip$$1 = tooltipVisible && getPieTooltip({\n      dataType: dataType,\n      innerRows: innerRows,\n      limitShowNum: limitShowNum,\n      digit: digit,\n      metrics: metrics,\n      dimension: dimension\n    });\n    var options = { series: series, legend: legend$$1, tooltip: tooltip$$1 };\n    return options;\n  };\n\n  var ring = function ring(columns, rows, settings, extra) {\n    return pie$1(columns, rows, settings, extra, true);\n  };\n\n  var VePie = _extends({}, Core, {\n    name: 'VePie',\n    data: function data() {\n      this.chartHandler = pie$1;\n      return {};\n    }\n  });\n\n  var VeRing = _extends({}, Core, {\n    name: 'VeRing',\n    data: function data() {\n      this.chartHandler = ring;\n      return {};\n    }\n  });\n\n  function getWaterfallTooltip(dataType, digit) {\n    return {\n      trigger: 'axis',\n      axisPointer: { type: 'shadow' },\n      formatter: function formatter(items) {\n        var item = items[1];\n        return [item.name + '<br/>' + item.seriesName + ' :', '' + getFormated(item.value, dataType, digit)].join('');\n      }\n    };\n  }\n\n  function getWaterfallXAxis(args) {\n    var dimension = args.dimension,\n        rows = args.rows,\n        remainStatus = args.remainStatus,\n        totalName = args.totalName,\n        remainName = args.remainName,\n        labelMap = args.labelMap,\n        xAxisName = args.xAxisName,\n        axisVisible = args.axisVisible;\n\n    var xAxisData = [totalName].concat(rows.map(function (row) {\n      return row[dimension];\n    }));\n    if (remainStatus === 'have-remain') {\n      xAxisData = xAxisData.concat([remainName]);\n    }\n\n    return {\n      type: 'category',\n      name: labelMap && labelMap[xAxisName] || xAxisName,\n      splitLine: { show: false },\n      data: xAxisData,\n      show: axisVisible\n    };\n  }\n\n  function getWaterfallYAxis(args) {\n    var dataType = args.dataType,\n        yAxisName = args.yAxisName,\n        axisVisible = args.axisVisible,\n        digit = args.digit,\n        labelMap = args.labelMap;\n\n    return {\n      type: 'value',\n      name: labelMap[yAxisName] != null ? labelMap[yAxisName] : yAxisName,\n      axisTick: { show: false },\n      axisLabel: {\n        formatter: function formatter(val) {\n          return getFormated(val, dataType, digit);\n        }\n      },\n      show: axisVisible\n    };\n  }\n\n  function getWaterfallSeries(args) {\n    var dataType = args.dataType,\n        rows = args.rows,\n        metrics = args.metrics,\n        totalNum = args.totalNum,\n        remainStatus = args.remainStatus,\n        dataSum = args.dataSum,\n        digit = args.digit;\n\n    var seriesBase = { type: 'bar', stack: '' };\n    var dataSumTemp = dataSum;\n    var totalNumTemp = totalNum;\n    var assistData = void 0;\n    var mainData = void 0;\n    var rowData = rows.map(function (row) {\n      return row[metrics];\n    });\n\n    if (remainStatus === 'have-remain') {\n      assistData = [0].concat(rows.map(function (row) {\n        totalNumTemp -= row[metrics];\n        return totalNumTemp;\n      })).concat([0]);\n      mainData = [totalNum].concat(rowData).concat([totalNum - dataSum]);\n    } else {\n      assistData = [0].concat(rows.map(function (row) {\n        dataSumTemp -= row[metrics];\n        return dataSumTemp;\n      }));\n      mainData = [dataSum].concat(rowData);\n    }\n    var series = [];\n\n    series.push(_extends({\n      name: '',\n      itemStyle: {\n        normal: { opacity: 0 },\n        emphasis: { opacity: 0 }\n      },\n      data: assistData\n    }, seriesBase));\n\n    series.push(_extends({\n      name: '',\n      label: {\n        normal: {\n          show: true,\n          position: 'top',\n          formatter: function formatter(item) {\n            return getFormated(item.value, dataType, digit);\n          }\n        }\n      },\n      data: mainData\n    }, seriesBase));\n    return series;\n  }\n\n  function getWaterfallRemainStatus(dataSum, totalNum) {\n    if (!totalNum) return 'not-total';\n    return totalNum > dataSum ? 'have-remain' : 'none-remain';\n  }\n\n  var waterfall = function waterfall(columns, rows, settings, extra) {\n    var _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$totalName = settings.totalName,\n        totalName = _settings$totalName === undefined ? '' : _settings$totalName,\n        totalNum = settings.totalNum,\n        _settings$remainName = settings.remainName,\n        remainName = _settings$remainName === undefined ? '' : _settings$remainName,\n        _settings$xAxisName = settings.xAxisName,\n        xAxisName = _settings$xAxisName === undefined ? dimension : _settings$xAxisName,\n        _settings$labelMap = settings.labelMap,\n        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,\n        _settings$axisVisible = settings.axisVisible,\n        axisVisible = _settings$axisVisible === undefined ? true : _settings$axisVisible,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit;\n    var tooltipVisible = extra.tooltipVisible;\n\n    var metricsTemp = columns.slice();\n    metricsTemp.splice(metricsTemp.indexOf(dimension), 1);\n    var metrics = metricsTemp[0];\n    var yAxisName = metrics;\n    var tooltip$$1 = tooltipVisible && getWaterfallTooltip(dataType, digit);\n    var dataSum = parseFloat(rows.reduce(function (pre, cur) {\n      return pre + Number(cur[metrics]);\n    }, 0).toFixed(digit));\n    var remainStatus = getWaterfallRemainStatus(dataSum, totalNum);\n    var xAxisParams = {\n      dimension: dimension,\n      rows: rows,\n      remainStatus: remainStatus,\n      totalName: totalName,\n      remainName: remainName,\n      xAxisName: xAxisName,\n      labelMap: labelMap,\n      axisVisible: axisVisible\n    };\n    var xAxis = getWaterfallXAxis(xAxisParams);\n    var yAxis = getWaterfallYAxis({ dataType: dataType, yAxisName: yAxisName, axisVisible: axisVisible, digit: digit, labelMap: labelMap });\n    var seriesParams = {\n      dataType: dataType,\n      rows: rows,\n      dimension: dimension,\n      metrics: metrics,\n      totalNum: totalNum,\n      remainStatus: remainStatus,\n      dataSum: dataSum,\n      digit: digit\n    };\n    var series = getWaterfallSeries(seriesParams);\n    var options = { tooltip: tooltip$$1, xAxis: xAxis, yAxis: yAxis, series: series };\n    return options;\n  };\n\n  var VeWaterfall = _extends({}, Core, {\n    name: 'VeWaterfall',\n    data: function data() {\n      this.chartHandler = waterfall;\n      return {};\n    }\n  });\n\n  function getFunnelTooltip(dataType, digit) {\n    return {\n      trigger: 'item',\n      formatter: function formatter(item) {\n        var tpl = [];\n        tpl.push(itemPoint(item.color));\n        tpl.push(item.name + ': ' + getFormated(item.data.realValue, dataType, digit));\n        return tpl.join('');\n      }\n    };\n  }\n\n  function getFunnelLegend(args) {\n    var data = args.data,\n        legendName = args.legendName;\n\n    return {\n      data: data,\n      formatter: function formatter(name) {\n        return legendName[name] != null ? legendName[name] : name;\n      }\n    };\n  }\n\n  function getFunnelSeries(args) {\n    var dimension = args.dimension,\n        metrics = args.metrics,\n        rows = args.rows,\n        sequence = args.sequence,\n        ascending = args.ascending,\n        label = args.label,\n        labelLine = args.labelLine,\n        itemStyle = args.itemStyle,\n        filterZero = args.filterZero,\n        useDefaultOrder = args.useDefaultOrder;\n\n    var series = { type: 'funnel' };\n    var innerRows = rows.sort(function (a, b) {\n      return sequence.indexOf(a[dimension]) - sequence.indexOf(b[dimension]);\n    });\n\n    if (filterZero) {\n      innerRows = innerRows.filter(function (row) {\n        return row[metrics];\n      });\n    }\n\n    var falseFunnel = false;\n    innerRows.some(function (row, index) {\n      if (index && row[metrics] > innerRows[index - 1][metrics]) {\n        falseFunnel = true;\n        return true;\n      }\n    });\n\n    var step = 100 / innerRows.length;\n\n    if (falseFunnel && !useDefaultOrder) {\n      series.data = innerRows.slice().reverse().map(function (row, index) {\n        return {\n          name: row[dimension],\n          value: (index + 1) * step,\n          realValue: row[metrics]\n        };\n      });\n    } else {\n      series.data = innerRows.map(function (row) {\n        return {\n          name: row[dimension],\n          value: row[metrics],\n          realValue: row[metrics]\n        };\n      });\n    }\n\n    if (ascending) series.sort = 'ascending';\n    if (label) series.label = label;\n    if (labelLine) series.labelLine = labelLine;\n    if (itemStyle) series.itemStyle = itemStyle;\n    return series;\n  }\n\n  var funnel$1 = function funnel$$1(outerColumns, outerRows, settings, extra) {\n    var columns = outerColumns.slice();\n    var rows = outerRows.slice();\n    var _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$sequence = settings.sequence,\n        sequence = _settings$sequence === undefined ? rows.map(function (row) {\n      return row[dimension];\n    }) : _settings$sequence,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        ascending = settings.ascending,\n        label = settings.label,\n        labelLine = settings.labelLine,\n        _settings$legendName = settings.legendName,\n        legendName = _settings$legendName === undefined ? {} : _settings$legendName,\n        itemStyle = settings.itemStyle,\n        filterZero = settings.filterZero,\n        useDefaultOrder = settings.useDefaultOrder;\n    var tooltipVisible = extra.tooltipVisible,\n        legendVisible = extra.legendVisible;\n\n    var metrics = void 0;\n    if (settings.metrics) {\n      metrics = settings.metrics;\n    } else {\n      var metricsTemp = columns.slice();\n      metricsTemp.splice(columns.indexOf(dimension), 1);\n      metrics = metricsTemp[0];\n    }\n\n    var tooltip$$1 = tooltipVisible && getFunnelTooltip(dataType, digit);\n    var legend$$1 = legendVisible && getFunnelLegend({ data: sequence, legendName: legendName });\n    var series = getFunnelSeries({\n      dimension: dimension,\n      metrics: metrics,\n      rows: rows,\n      sequence: sequence,\n      ascending: ascending,\n      label: label,\n      labelLine: labelLine,\n      itemStyle: itemStyle,\n      filterZero: filterZero,\n      useDefaultOrder: useDefaultOrder\n    });\n    var options = { tooltip: tooltip$$1, legend: legend$$1, series: series };\n    return options;\n  };\n\n  var VeFunnel = _extends({}, Core, {\n    name: 'VeFunnel',\n    data: function data() {\n      this.chartHandler = funnel$1;\n      return {};\n    }\n  });\n\n  function getRadarLegend(rows, dimension, legendName) {\n    var legendData = rows.map(function (row) {\n      return row[dimension];\n    });\n\n    return {\n      data: legendData,\n      formatter: function formatter(name) {\n        return legendName[name] != null ? legendName[name] : name;\n      }\n    };\n  }\n\n  function getRadarTooltip(dataType, radar$$1, digit) {\n    var typeTemp = [];\n    var nameTemp = [];\n    radar$$1.indicator.map(function (item, index) {\n      typeTemp[index] = dataType[item.name];\n      nameTemp[index] = item.name;\n    });\n    return {\n      formatter: function formatter(item) {\n        var tpl = [];\n        tpl.push(itemPoint(item.color));\n        tpl.push(item.name + '<br />');\n        item.data.value.forEach(function (val, index) {\n          tpl.push(nameTemp[index] + ': ');\n          tpl.push(getFormated(val, typeTemp[index], digit) + '<br />');\n        });\n        return tpl.join('');\n      }\n    };\n  }\n\n  function getRadarSetting(rows, metrics, labelMap) {\n    var settingBase = {\n      indicator: [],\n      shape: 'circle',\n      splitNumber: 5\n    };\n    var indicatorTemp = {};\n    rows.forEach(function (items) {\n      metrics.forEach(function (item) {\n        var key = labelMap[item] != null ? labelMap[item] : item;\n        if (!indicatorTemp[key]) {\n          indicatorTemp[key] = [items[item]];\n        } else {\n          indicatorTemp[key].push(items[item]);\n        }\n      });\n    });\n    settingBase.indicator = Object.keys(indicatorTemp).map(function (key) {\n      return {\n        name: key,\n        max: Math.max.apply(null, indicatorTemp[key])\n      };\n    });\n    return settingBase;\n  }\n\n  function getRadarSeries(args) {\n    var rows = args.rows,\n        dimension = args.dimension,\n        metrics = args.metrics,\n        radar$$1 = args.radar,\n        label = args.label,\n        itemStyle = args.itemStyle,\n        lineStyle = args.lineStyle,\n        labelMap = args.labelMap,\n        areaStyle = args.areaStyle;\n\n    var radarIndexObj = {};\n    radar$$1.indicator.forEach(function (item, index) {\n      var name = item.name;\n      radarIndexObj[name] = index;\n    });\n\n    var seriesData = rows.map(function (row) {\n      var serieData = {\n        value: [],\n        name: row[dimension]\n      };\n      Object.keys(row).forEach(function (key) {\n        if (~metrics.indexOf(key)) {\n          var k = labelMap[key] != null ? radarIndexObj[labelMap[key]] : radarIndexObj[key];\n          serieData.value[k] = row[key];\n        }\n      });\n      return serieData;\n    });\n    var result = {\n      name: dimension,\n      type: 'radar',\n      data: seriesData\n    };\n    if (label) result.label = label;\n    if (itemStyle) result.itemStyle = itemStyle;\n    if (lineStyle) result.lineStyle = lineStyle;\n    if (areaStyle) result.areaStyle = areaStyle;\n    return [result];\n  }\n\n  var radar$1 = function radar$$1(columns, rows, settings, extra) {\n    var _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? {} : _settings$dataType,\n        _settings$legendName = settings.legendName,\n        legendName = _settings$legendName === undefined ? {} : _settings$legendName,\n        _settings$labelMap = settings.labelMap,\n        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        label = settings.label,\n        itemStyle = settings.itemStyle,\n        lineStyle = settings.lineStyle,\n        areaStyle = settings.areaStyle;\n    var tooltipVisible = extra.tooltipVisible,\n        legendVisible = extra.legendVisible;\n\n    var metrics = columns.slice();\n    if (settings.metrics) {\n      metrics = settings.metrics;\n    } else {\n      metrics.splice(columns.indexOf(dimension), 1);\n    }\n    var legend$$1 = legendVisible && getRadarLegend(rows, dimension, legendName);\n    var radar$$1 = getRadarSetting(rows, metrics, labelMap);\n    var tooltip$$1 = tooltipVisible && getRadarTooltip(dataType, radar$$1, digit);\n    var series = getRadarSeries({\n      rows: rows,\n      dimension: dimension,\n      metrics: metrics,\n      radar: radar$$1,\n      label: label,\n      itemStyle: itemStyle,\n      lineStyle: lineStyle,\n      labelMap: labelMap,\n      areaStyle: areaStyle\n    });\n    var options = { legend: legend$$1, tooltip: tooltip$$1, radar: radar$$1, series: series };\n    return options;\n  };\n\n  var VeRadar = _extends({}, Core, {\n    name: 'VeRadar',\n    data: function data() {\n      this.chartHandler = radar$1;\n      return {};\n    }\n  });\n\n  var VeChart = _extends({}, Core, {\n    name: 'VeChart',\n    data: function data() {\n      this.chartLib = {\n        bar: bar$1,\n        histogram: histogram,\n        line: line$1,\n        pie: pie$1,\n        ring: ring,\n        funnel: funnel$1,\n        radar: radar$1,\n        waterfall: waterfall\n      };\n      this.chartHandler = this.chartLib[this.settings.type];\n      return {};\n    }\n  });\n\n  function getTooltip(dataType, digit, dataStore, metrics, color, labelMap) {\n    return {\n      formatter: function formatter(item) {\n        var tpl = [];\n        if (!item.name) return '';\n        tpl.push(item.name + '<br>');\n        metrics.forEach(function (label, index) {\n          var title = labelMap[label] != null ? labelMap[label] : label;\n          tpl.push(itemPoint(color[index]) + ' ' + title + ' : ');\n          if (dataStore[item.name]) {\n            tpl.push(getFormated(dataStore[item.name][label], dataType[label], digit));\n          } else {\n            tpl.push('-');\n          }\n          tpl.push('<br>');\n        });\n        return tpl.join(' ');\n      }\n    };\n  }\n\n  function getSeries(args) {\n    var position = args.position,\n        selectData = args.selectData,\n        dimension = args.dimension,\n        metrics = args.metrics,\n        rows = args.rows,\n        label = args.label,\n        itemStyle = args.itemStyle,\n        selectedMode = args.selectedMode,\n        roam = args.roam,\n        center = args.center,\n        aspectScale = args.aspectScale,\n        boundingCoords = args.boundingCoords,\n        zoom = args.zoom,\n        labelMap = args.labelMap,\n        scaleLimit = args.scaleLimit,\n        mapGrid = args.mapGrid;\n\n    var result = [];\n    var mapBase = {\n      type: 'map',\n      mapType: position\n    };\n\n    metrics.forEach(function (itemName) {\n      var itemResult = _extends({\n        name: labelMap[itemName] != null ? labelMap[itemName] : itemName,\n        data: [],\n        selectedMode: selectedMode,\n        roam: roam,\n        center: center,\n        aspectScale: aspectScale,\n        boundingCoords: boundingCoords,\n        zoom: zoom,\n        scaleLimit: scaleLimit\n      }, mapBase);\n\n      if (mapGrid) {\n        Object.keys(mapGrid).forEach(function (key) {\n          itemResult[key] = mapGrid[key];\n        });\n      }\n\n      setGeoLabel(itemStyle, itemResult, 'itemStyle');\n      setGeoLabel(label, itemResult, 'label');\n\n      rows.forEach(function (row) {\n        itemResult.data.push({\n          name: row[dimension],\n          value: row[itemName],\n          selected: selectData\n        });\n      });\n      result.push(itemResult);\n    });\n\n    return result;\n  }\n\n  function setGeoLabel(value, target, label) {\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      target[label] = value;\n    } else if (value) {\n      target[label] = {\n        normal: { show: true },\n        emphasis: { show: true }\n      };\n    }\n  }\n\n  function getLegendMap(args) {\n    var metrics = args.metrics,\n        legendName = args.legendName,\n        labelMap = args.labelMap;\n\n    if (!legendName && !labelMap) return { data: metrics };\n    var data = labelMap ? metrics.map(function (item) {\n      return labelMap[item] == null ? item : labelMap[item];\n    }) : metrics;\n    return {\n      data: data,\n      formatter: function formatter(name) {\n        return legendName[name] != null ? legendName[name] : name;\n      }\n    };\n  }\n\n  function registerMap(args, mapOrigin) {\n    var _once = args._once,\n        registerSign = args.registerSign,\n        beforeRegisterMap = args.beforeRegisterMap,\n        beforeRegisterMapOnce = args.beforeRegisterMapOnce,\n        registerSignOnce = args.registerSignOnce,\n        position = args.position,\n        specialAreas = args.specialAreas;\n\n    if (!_once[registerSign]) {\n      if (beforeRegisterMap) mapOrigin = beforeRegisterMap(mapOrigin);\n      if (beforeRegisterMapOnce && !_once[registerSignOnce]) {\n        _once[registerSignOnce] = true;\n        mapOrigin = beforeRegisterMapOnce(mapOrigin);\n      }\n      _once[registerSign] = true;\n      echartsLib.registerMap(position, mapOrigin, specialAreas);\n    }\n  }\n\n  var map$1 = function map$$1(columns, rows, settings, extra) {\n    var _settings$position = settings.position,\n        position = _settings$position === undefined ? 'china' : _settings$position,\n        _settings$selectData = settings.selectData,\n        selectData = _settings$selectData === undefined ? false : _settings$selectData,\n        selectedMode = settings.selectedMode,\n        _settings$label = settings.label,\n        label = _settings$label === undefined ? true : _settings$label,\n        _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? {} : _settings$dataType,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        roam = settings.roam,\n        center = settings.center,\n        aspectScale = settings.aspectScale,\n        boundingCoords = settings.boundingCoords,\n        zoom = settings.zoom,\n        scaleLimit = settings.scaleLimit,\n        _settings$legendName = settings.legendName,\n        legendName = _settings$legendName === undefined ? {} : _settings$legendName,\n        _settings$labelMap = settings.labelMap,\n        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,\n        mapGrid = settings.mapGrid,\n        itemStyle = settings.itemStyle,\n        positionJsonLink = settings.positionJsonLink,\n        beforeRegisterMap = settings.beforeRegisterMap,\n        beforeRegisterMapOnce = settings.beforeRegisterMapOnce,\n        _settings$mapURLProfi = settings.mapURLProfix,\n        mapURLProfix = _settings$mapURLProfi === undefined ? 'https://unpkg.com/echarts@3.6.2/map/json/' : _settings$mapURLProfi,\n        _settings$specialArea = settings.specialAreas,\n        specialAreas = _settings$specialArea === undefined ? {} : _settings$specialArea;\n\n    var mapOrigin = settings.mapOrigin;\n    var metrics = columns.slice();\n    if (settings.metrics) {\n      metrics = settings.metrics;\n    } else {\n      metrics.splice(columns.indexOf(dimension), 1);\n    }\n    var tooltipVisible = extra.tooltipVisible,\n        legendVisible = extra.legendVisible,\n        color = extra.color,\n        _once = extra._once;\n\n    var dataStore = {};\n    rows.forEach(function (row) {\n      dataStore[row[dimension]] = row;\n    });\n    var tooltip$$1 = tooltipVisible && getTooltip(dataType, digit, dataStore, metrics, color, labelMap);\n    var legend$$1 = legendVisible && getLegendMap({ metrics: metrics, legendName: legendName, labelMap: labelMap });\n    var seriesParams = {\n      position: position,\n      selectData: selectData,\n      label: label,\n      itemStyle: itemStyle,\n      dimension: dimension,\n      metrics: metrics,\n      rows: rows,\n      selectedMode: selectedMode,\n      roam: roam,\n      center: center,\n      aspectScale: aspectScale,\n      boundingCoords: boundingCoords,\n      zoom: zoom,\n      labelMap: labelMap,\n      scaleLimit: scaleLimit,\n      mapGrid: mapGrid\n    };\n    var series = getSeries(seriesParams);\n    var registerOptions = {\n      _once: _once,\n      beforeRegisterMap: beforeRegisterMap,\n      beforeRegisterMapOnce: beforeRegisterMapOnce,\n      registerSign: 'MAP_REGISTER_' + position,\n      registerSignOnce: 'ONCE_MAP_REGISTER_' + position,\n      position: position,\n      specialAreas: specialAreas\n    };\n    if (mapOrigin) {\n      registerMap(registerOptions, mapOrigin);\n      return { series: series, tooltip: tooltip$$1, legend: legend$$1 };\n    } else {\n      return getMapJSON({\n        position: position,\n        positionJsonLink: positionJsonLink,\n        beforeRegisterMapOnce: beforeRegisterMapOnce,\n        mapURLProfix: mapURLProfix\n      }).then(function (json) {\n        registerMap(registerOptions, json);\n        return { series: series, tooltip: tooltip$$1, legend: legend$$1 };\n      });\n    }\n  };\n\n  var VeMap = _extends({}, Core, {\n    name: 'VeMap',\n    data: function data() {\n      this.chartHandler = map$1;\n      return {};\n    }\n  });\n\n  var bmap$1 = function bmap$$1(_, __, settings, extra) {\n    var key = settings.key,\n        v = settings.v,\n        bmap$$1 = settings.bmap,\n        useOuterMap = settings.useOuterMap;\n    var _once = extra._once;\n\n    var registerSign = 'bmap_register';\n    if (!key && !useOuterMap) console.warn('settings.key must be a string.');\n    if (_once[registerSign]) return {};\n    _once[registerSign] = true;\n    if (useOuterMap) return { bmap: bmap$$1 };\n    return getBmap(key, v).then(function (_) {\n      return { bmap: bmap$$1 };\n    });\n  };\n\n  var VeBmap = _extends({}, Core, {\n    name: 'VeBmap',\n    data: function data() {\n      this.chartHandler = bmap$1;\n      return {};\n    }\n  });\n\n  var amap = function amap(_, __, settings, extra) {\n    var key = settings.key,\n        v = settings.v,\n        amap = settings.amap,\n        useOuterMap = settings.useOuterMap;\n    var _once = extra._once;\n\n    var registerSign = 'amap_register';\n    if (!key && !useOuterMap) console.warn('settings.key must be a string.');\n    if (_once[registerSign]) return {};\n    _once[registerSign] = true;\n    if (useOuterMap) return { amap: amap };\n    return getAmap(key, v).then(function (_) {\n      return { amap: amap };\n    });\n  };\n\n  var VeAmap = _extends({}, Core, {\n    name: 'VeAmap',\n    data: function data() {\n      this.chartHandler = amap;\n      return {};\n    }\n  });\n\n  function getTooltip$1(args) {\n    var itemDataType = args.itemDataType,\n        linksDataType = args.linksDataType,\n        digit = args.digit;\n\n    return {\n      trigger: 'item',\n      formatter: function formatter(item) {\n        var tpl = [];\n        var name = item.name,\n            data = item.data,\n            value = item.value,\n            color = item.color;\n\n        tpl.push(itemPoint(color));\n        tpl.push(name + ' : ');\n        if (data && data.source) {\n          tpl.push(getFormated(value, linksDataType, digit) + '<br />');\n        } else {\n          tpl.push(getFormated(value, itemDataType, digit) + '<br />');\n        }\n        return tpl.join('');\n      }\n    };\n  }\n\n  function getSeries$1(args) {\n    var rows = args.rows,\n        dimension = args.dimension,\n        metrics = args.metrics,\n        links = args.links,\n        valueFull = args.valueFull,\n        useDataValue = args.useDataValue,\n        label = args.label,\n        itemStyle = args.itemStyle,\n        lineStyle = args.lineStyle;\n\n    var dataMap = {};\n    var seriesData = rows.map(function (row) {\n      dataMap[row[dimension]] = row[metrics];\n      return { name: row[dimension], value: row[metrics] };\n    });\n    var innerLinks = null;\n    if (useDataValue) {\n      innerLinks = links.map(function (link) {\n        return _extends({}, link, { value: dataMap[link.target] });\n      });\n    } else if (!valueFull) {\n      innerLinks = links.map(function (link) {\n        return link.value == null ? _extends({}, link, { value: dataMap[link.target] }) : link;\n      });\n    } else {\n      innerLinks = links;\n    }\n\n    var result = {\n      type: 'sankey',\n      data: seriesData,\n      links: innerLinks\n    };\n    if (label) result.label = label;\n    if (itemStyle) result.itemStyle = itemStyle;\n    if (lineStyle) result.lineStyle = lineStyle;\n    return [result];\n  }\n\n  var sankey$1 = function sankey$$1(columns, rows, settings, extra) {\n    var links = settings.links,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$metrics = settings.metrics,\n        metrics = _settings$metrics === undefined ? columns[1] : _settings$metrics,\n        _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? ['normal', 'normal'] : _settings$dataType,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        _settings$valueFull = settings.valueFull,\n        valueFull = _settings$valueFull === undefined ? false : _settings$valueFull,\n        _settings$useDataValu = settings.useDataValue,\n        useDataValue = _settings$useDataValu === undefined ? false : _settings$useDataValu,\n        label = settings.label,\n        itemStyle = settings.itemStyle,\n        lineStyle = settings.lineStyle;\n\n\n    if (!links) {\n      console.warn('links is needed in settings!');\n      return;\n    }\n\n    var itemDataType = dataType[0];\n    var linksDataType = dataType[1];\n    var tooltip$$1 = getTooltip$1({\n      itemDataType: itemDataType,\n      linksDataType: linksDataType,\n      digit: digit\n    });\n    var series = getSeries$1({\n      rows: rows,\n      dimension: dimension,\n      metrics: metrics,\n      links: links,\n      valueFull: valueFull,\n      useDataValue: useDataValue,\n      label: label,\n      itemStyle: itemStyle,\n      lineStyle: lineStyle\n    });\n    return { tooltip: tooltip$$1, series: series };\n  };\n\n  var VeSankey = _extends({}, Core, {\n    name: 'VeSankey',\n    data: function data() {\n      this.chartHandler = sankey$1;\n      return {};\n    }\n  });\n\n  function getAxisList(rows, label) {\n    var result = [];\n    rows.forEach(function (row) {\n      if (!~result.indexOf(row[label])) result.push(row[label]);\n    });\n    return result;\n  }\n\n  function getData(args) {\n    var rows = args.rows,\n        innerXAxisList = args.innerXAxisList,\n        innerYAxisList = args.innerYAxisList,\n        xDim = args.xDim,\n        yDim = args.yDim,\n        metrics = args.metrics,\n        type = args.type,\n        extraMetrics = args.extraMetrics;\n\n    var result = null;\n    if (type === 'cartesian') {\n      result = rows.map(function (row) {\n        var xIndex = innerXAxisList.indexOf(row[xDim]);\n        var yIndex = innerYAxisList.indexOf(row[yDim]);\n        var value = metrics ? row[metrics] : 1;\n        var extraData = extraMetrics.map(function (m) {\n          return row[m] || '-';\n        });\n        return { value: [xIndex, yIndex, value].concat(extraData) };\n      });\n    } else {\n      result = rows.map(function (row) {\n        var value = metrics ? row[metrics] : 1;\n        return { value: [row[xDim], row[yDim], value] };\n      });\n    }\n    return result;\n  }\n\n  function getAxis(list, name) {\n    return {\n      type: 'category',\n      data: list,\n      name: name,\n      nameLocation: 'end',\n      splitArea: { show: true }\n    };\n  }\n\n  function getVisualMap(args) {\n    var min = args.innerMin,\n        max = args.innerMax,\n        type = args.type,\n        heatColor = args.heatColor,\n        series = args.series;\n\n    var result = {\n      min: min,\n      max: max,\n      calculable: true\n    };\n    var extra = null;\n    if (type === 'map') {\n      extra = {\n        orient: 'vertical',\n        left: 0,\n        bottom: 0,\n        inRange: { color: heatColor || HEAT_MAP_COLOR }\n      };\n      if (!series[0].data.length) extra.show = false;\n    } else if (type === 'bmap' || type === 'amap') {\n      extra = {\n        show: false,\n        orient: 'vertical',\n        left: 0,\n        bottom: 0,\n        inRange: { color: heatColor || HEAT_BMAP_COLOR }\n      };\n    } else {\n      extra = {\n        orient: 'horizontal',\n        left: 'center',\n        bottom: 10,\n        dimension: 2,\n        inRange: heatColor && { color: heatColor }\n      };\n    }\n\n    return _extends(result, extra);\n  }\n\n  function getSeries$2(args) {\n    var chartData = args.chartData;\n\n    return [{\n      type: 'heatmap',\n      data: chartData\n    }];\n  }\n\n  function getTooltip$2(args) {\n    var dataType = args.dataType,\n        innerXAxisList = args.innerXAxisList,\n        innerYAxisList = args.innerYAxisList,\n        digit = args.digit,\n        extraMetrics = args.extraMetrics,\n        metrics = args.metrics;\n\n\n    return {\n      trigger: 'item',\n      formatter: function formatter(_ref) {\n        var color = _ref.color,\n            _ref$data$value = toArray(_ref.data.value),\n            xDim = _ref$data$value[0],\n            yDim = _ref$data$value[1],\n            value = _ref$data$value[2],\n            extraData = _ref$data$value.slice(3);\n\n        var tpl = [];\n        tpl.push(innerXAxisList[xDim] + ' ~ ' + innerYAxisList[yDim] + '<br>');\n        extraMetrics.forEach(function (m, index) {\n          tpl.push(m + ': ' + extraData[index] + '<br>');\n        });\n        tpl.push(itemPoint(color) + ' ' + metrics + ': ' + getFormated(value, dataType, digit) + '<br>');\n        return tpl.join('');\n      }\n    };\n  }\n\n  var heatmap$1 = function heatmap$$1(columns, rows, settings, status) {\n    var _settings$type = settings.type,\n        type = _settings$type === undefined ? 'cartesian' : _settings$type,\n        xAxisList = settings.xAxisList,\n        yAxisList = settings.yAxisList,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? [columns[0], columns[1]] : _settings$dimension,\n        _settings$metrics = settings.metrics,\n        metrics = _settings$metrics === undefined ? columns[2] : _settings$metrics,\n        _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,\n        min = settings.min,\n        max = settings.max,\n        digit = settings.digit,\n        bmap$$1 = settings.bmap,\n        amap = settings.amap,\n        geo = settings.geo,\n        key = settings.key,\n        _settings$v = settings.v,\n        v = _settings$v === undefined ? '2.0' : _settings$v,\n        position = settings.position,\n        positionJsonLink = settings.positionJsonLink,\n        beforeRegisterMap = settings.beforeRegisterMap,\n        _settings$pointSize = settings.pointSize,\n        pointSize = _settings$pointSize === undefined ? 10 : _settings$pointSize,\n        _settings$blurSize = settings.blurSize,\n        blurSize = _settings$blurSize === undefined ? 5 : _settings$blurSize,\n        heatColor = settings.heatColor,\n        yAxisName = settings.yAxisName,\n        xAxisName = settings.xAxisName,\n        beforeRegisterMapOnce = settings.beforeRegisterMapOnce,\n        _settings$mapURLProfi = settings.mapURLProfix,\n        mapURLProfix = _settings$mapURLProfi === undefined ? 'https://unpkg.com/echarts@3.6.2/map/json/' : _settings$mapURLProfi,\n        _settings$specialArea = settings.specialAreas,\n        specialAreas = _settings$specialArea === undefined ? {} : _settings$specialArea;\n    var tooltipVisible = status.tooltipVisible;\n\n    var innerXAxisList = xAxisList;\n    var innerYAxisList = yAxisList;\n    var chartData = [];\n    // add extraMetrics prop for data which only display in tooltip\n    var extraMetrics = [];\n    var mainColumn = dimension.concat([metrics]);\n    columns.forEach(function (column) {\n      if (!~mainColumn.indexOf(column)) extraMetrics.push(column);\n    });\n\n    if (type === 'cartesian') {\n      if (!innerXAxisList || !innerXAxisList.length) {\n        innerXAxisList = getAxisList(rows, dimension[0]);\n      }\n      if (!innerYAxisList || !innerYAxisList.length) {\n        innerYAxisList = getAxisList(rows, dimension[1]);\n      }\n      chartData = getData({\n        rows: rows,\n        innerXAxisList: innerXAxisList,\n        innerYAxisList: innerYAxisList,\n        xDim: dimension[0],\n        yDim: dimension[1],\n        metrics: metrics,\n        type: type,\n        extraMetrics: extraMetrics\n      });\n    } else {\n      chartData = getData({\n        rows: rows,\n        xDim: dimension[0],\n        yDim: dimension[1],\n        metrics: metrics,\n        type: type,\n        extraMetrics: extraMetrics\n      });\n    }\n    var metricsList = metrics ? rows.map(function (row) {\n      return row[metrics];\n    }) : [0, 5];\n    if (!metricsList.length) metricsList = [0];\n    var innerMin = min || Math.min.apply(null, metricsList);\n    var innerMax = max || Math.max.apply(null, metricsList);\n\n    var xAxis = getAxis(innerXAxisList, xAxisName);\n    var yAxis = getAxis(innerYAxisList, yAxisName);\n    var series = getSeries$2({ chartData: chartData });\n    var visualMap$$1 = getVisualMap({ innerMin: innerMin, innerMax: innerMax, type: type, heatColor: heatColor, series: series });\n    var tooltip$$1 = tooltipVisible && getTooltip$2({\n      dataType: dataType,\n      innerXAxisList: innerXAxisList,\n      innerYAxisList: innerYAxisList,\n      digit: digit,\n      extraMetrics: extraMetrics,\n      metrics: metrics\n    });\n\n    var options = { visualMap: visualMap$$1, series: series };\n    if (type === 'bmap') {\n      _extends(options.series[0], { coordinateSystem: 'bmap', pointSize: pointSize, blurSize: blurSize });\n\n      return getBmap(key, v).then(function (_) {\n        return _extends({ bmap: bmap$$1 }, options);\n      });\n    } else if (type === 'map') {\n      options.series[0].coordinateSystem = 'geo';\n      return getMapJSON({\n        position: position,\n        positionJsonLink: positionJsonLink,\n        beforeRegisterMapOnce: beforeRegisterMapOnce,\n        mapURLProfix: mapURLProfix\n      }).then(function (json) {\n        var geoAttr = _extends({ map: position }, geo);\n        if (beforeRegisterMap) json = beforeRegisterMap(json);\n        echartsLib.registerMap(position, json, specialAreas);\n        return _extends({ geo: geoAttr }, options);\n      });\n    } else if (type === 'amap') {\n      _extends(options.series[0], { coordinateSystem: 'amap', pointSize: pointSize, blurSize: blurSize });\n\n      return getAmap(key, v).then(function (_) {\n        return _extends({ amap: amap }, options);\n      });\n    } else {\n      return _extends({ xAxis: xAxis, yAxis: yAxis, tooltip: tooltip$$1 }, options);\n    }\n  };\n\n  var VeHeatmap = _extends({}, Core, {\n    name: 'VeHeatmap',\n    data: function data() {\n      this.chartHandler = heatmap$1;\n      return {};\n    }\n  });\n\n  function getScatterLegend(dataLabels, legendName) {\n    return {\n      data: dataLabels,\n      formatter: function formatter(name) {\n        return legendName[name] != null ? legendName[name] : name;\n      }\n    };\n  }\n\n  function getScatterTooltip(args) {\n    var tooltipTrigger = args.tooltipTrigger;\n\n    return {\n      trigger: tooltipTrigger,\n      formatter: function formatter(item) {\n        if (isArray(item)) {\n          return item.map(function (i) {\n            return getTooltipContent(i, args);\n          }).join('');\n        } else {\n          return getTooltipContent(item, args);\n        }\n      }\n    };\n  }\n\n  function getTooltipContent(item, args) {\n    var labelMap = args.labelMap,\n        columns = args.columns,\n        dataType = args.dataType,\n        digit = args.digit;\n\n    var tpl = [];\n    var color = item.color,\n        seriesName = item.seriesName,\n        value = item.data.value;\n\n    tpl.push(itemPoint(color) + ' ' + seriesName + '<br>');\n    value.forEach(function (d, i) {\n      var name = labelMap[columns[i]] || columns[i];\n      var num = isNaN(d) ? d : getFormated(d, dataType[columns[i]], digit);\n      tpl.push(name + ': ' + num + '<br>');\n    });\n    return tpl.join('');\n  }\n\n  function getScatterXAxis(args) {\n    var xAxisName = args.xAxisName,\n        axisVisible = args.axisVisible,\n        xAxisType = args.xAxisType,\n        rows = args.rows,\n        dataLabels = args.dataLabels,\n        dimension = args.dimension;\n\n    var data = [];\n    dataLabels.forEach(function (dataLabel) {\n      var itemData = rows[dataLabel];\n      itemData.forEach(function (item) {\n        var name = item[dimension];\n        if (name && !~data.indexOf(name)) data.push(name);\n      });\n    });\n\n    return [{\n      type: xAxisType,\n      show: axisVisible,\n      name: xAxisName,\n      data: data\n    }];\n  }\n\n  function getScatterYAxis(args) {\n    var min = args.min,\n        max = args.max,\n        scale = args.scale,\n        yAxisName = args.yAxisName,\n        dataType = args.dataType,\n        metrics = args.metrics,\n        digit = args.digit,\n        axisVisible = args.axisVisible;\n\n\n    return {\n      type: 'value',\n      show: axisVisible,\n      scale: scale,\n      min: min,\n      max: max,\n      axisTick: { show: false },\n      name: yAxisName,\n      axisLabel: {\n        formatter: function formatter(val) {\n          return getFormated(val, dataType[metrics[0]], digit);\n        }\n      }\n    };\n  }\n\n  function getScatterSeries(args) {\n    var rows = args.rows,\n        dataLabels = args.dataLabels,\n        columns = args.columns,\n        metrics = args.metrics,\n        dimension = args.dimension,\n        label = args.label,\n        itemStyle = args.itemStyle,\n        symbol = args.symbol,\n        symbolSizeMax = args.symbolSizeMax,\n        symbolSize = args.symbolSize,\n        symbolRotate = args.symbolRotate,\n        symbolOffset = args.symbolOffset,\n        cursor = args.cursor;\n\n    var extraMetrics = columns.filter(function (column) {\n      return !~metrics.indexOf(column) && column !== dimension;\n    });\n    var numbers = [];\n    dataLabels.forEach(function (dataLabel) {\n      rows[dataLabel].forEach(function (row) {\n        numbers.push(row[metrics[1]]);\n      });\n    });\n    var maxNum = Math.max.apply(null, numbers);\n\n    var series = [];\n    dataLabels.forEach(function (dataLabel) {\n      var result = [];\n      var itemData = rows[dataLabel];\n      itemData.forEach(function (item) {\n        var itemResult = { value: [] };\n        itemResult.value.push(item[dimension], item[metrics[0]], item[metrics[1]]);\n        extraMetrics.forEach(function (ext) {\n          itemResult.value.push(item[ext]);\n        });\n        itemResult.symbolSize = symbolSize || item[metrics[1]] / maxNum * symbolSizeMax;\n        result.push(itemResult);\n      });\n      series.push({\n        type: 'scatter',\n        data: result,\n        name: dataLabel,\n        label: label,\n        itemStyle: itemStyle,\n        symbol: symbol,\n        symbolRotate: symbolRotate,\n        symbolOffset: symbolOffset,\n        cursor: cursor\n      });\n    });\n    return series;\n  }\n\n  var scatter$1 = function scatter$$1(columns, rows, settings, extra) {\n    var _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$metrics = settings.metrics,\n        metrics = _settings$metrics === undefined ? [columns[1], columns[2]] : _settings$metrics,\n        _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? {} : _settings$dataType,\n        _settings$xAxisType = settings.xAxisType,\n        xAxisType = _settings$xAxisType === undefined ? 'category' : _settings$xAxisType,\n        xAxisName = settings.xAxisName,\n        yAxisName = settings.yAxisName,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        _settings$legendName = settings.legendName,\n        legendName = _settings$legendName === undefined ? {} : _settings$legendName,\n        _settings$labelMap = settings.labelMap,\n        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,\n        _settings$tooltipTrig = settings.tooltipTrigger,\n        tooltipTrigger = _settings$tooltipTrig === undefined ? 'item' : _settings$tooltipTrig,\n        _settings$axisVisible = settings.axisVisible,\n        axisVisible = _settings$axisVisible === undefined ? true : _settings$axisVisible,\n        _settings$symbolSizeM = settings.symbolSizeMax,\n        symbolSizeMax = _settings$symbolSizeM === undefined ? 50 : _settings$symbolSizeM,\n        symbol = settings.symbol,\n        symbolSize = settings.symbolSize,\n        symbolRotate = settings.symbolRotate,\n        symbolOffset = settings.symbolOffset,\n        cursor = settings.cursor,\n        min = settings.min,\n        max = settings.max,\n        scale = settings.scale,\n        label = settings.label,\n        itemStyle = settings.itemStyle;\n\n\n    if (isArray(rows)) {\n      var lineSettings = _extends({}, settings, {\n        xAxisName: xAxisName ? [xAxisName] : undefined,\n        yAxisName: yAxisName ? [yAxisName] : undefined,\n        scale: scale ? [scale] : undefined,\n        min: min ? [min] : undefined,\n        max: max ? [max] : undefined,\n        dimension: dimension ? [dimension] : undefined\n      });\n      var options = line$1(columns, rows, lineSettings, extra);\n      if (!options || !options.series) return {};\n      options.series.forEach(function (item) {\n        _extends(item, {\n          type: 'scatter',\n          symbol: symbol,\n          symbolSize: symbolSize || 10,\n          symbolRotate: symbolRotate,\n          symbolOffset: symbolOffset,\n          cursor: cursor,\n          label: label,\n          itemStyle: itemStyle\n        });\n      });\n      return options;\n    }\n\n    var tooltipVisible = extra.tooltipVisible,\n        legendVisible = extra.legendVisible;\n\n    var dataLabels = Object.keys(rows);\n\n    var legend$$1 = legendVisible && getScatterLegend(dataLabels, legendName);\n    var tooltip$$1 = tooltipVisible && getScatterTooltip({\n      tooltipTrigger: tooltipTrigger,\n      labelMap: labelMap,\n      columns: columns,\n      dataType: dataType,\n      digit: digit\n    });\n    var xAxis = getScatterXAxis({\n      xAxisName: xAxisName,\n      axisVisible: axisVisible,\n      xAxisType: xAxisType,\n      dataLabels: dataLabels,\n      dimension: dimension,\n      rows: rows\n    });\n    var yAxis = getScatterYAxis({\n      min: min,\n      max: max,\n      scale: scale,\n      yAxisName: yAxisName,\n      dataType: dataType,\n      metrics: metrics,\n      digit: digit,\n      axisVisible: axisVisible\n    });\n    var series = getScatterSeries({\n      rows: rows,\n      dataLabels: dataLabels,\n      columns: columns,\n      metrics: metrics,\n      dimension: dimension,\n      label: label,\n      itemStyle: itemStyle,\n      symbol: symbol,\n      symbolSizeMax: symbolSizeMax,\n      symbolSize: symbolSize,\n      symbolRotate: symbolRotate,\n      symbolOffset: symbolOffset,\n      cursor: cursor\n    });\n    return { legend: legend$$1, tooltip: tooltip$$1, xAxis: xAxis, yAxis: yAxis, series: series };\n  };\n\n  var VeScatter = _extends({}, Core, {\n    name: 'VeScatter',\n    data: function data() {\n      this.chartHandler = scatter$1;\n      return {};\n    }\n  });\n\n  var DEFAULT_MA = [5, 10, 20, 30];\n  var DEFAULT_K_NAME = 'K';\n  var DEFAULT_DOWN_COLOR = '#ec0000';\n  var DEFAULT_UP_COLOR = '#00da3c';\n  var DEFAULT_START = 50;\n  var DEFAULT_END = 100;\n  var SHOW_FALSE = { show: false };\n\n  function getCandleLegend(args) {\n    var showMA = args.showMA,\n        MA = args.MA,\n        legendName = args.legendName,\n        labelMap = args.labelMap;\n\n    var data = [DEFAULT_K_NAME];\n    if (showMA) data = data.concat(MA.map(function (v) {\n      return 'MA' + v;\n    }));\n    if (labelMap) data = data.map(function (v) {\n      return labelMap[v] == null ? v : labelMap[v];\n    });\n    return {\n      data: data,\n      formatter: function formatter(name) {\n        return legendName[name] != null ? legendName[name] : name;\n      }\n    };\n  }\n\n  function getCandleTooltip(args) {\n    var metrics = args.metrics,\n        dataType = args.dataType,\n        digit = args.digit,\n        labelMap = args.labelMap;\n\n    return {\n      trigger: 'axis',\n      axisPointer: { type: 'cross' },\n      position: function position(pos, params, el, elRect, size) {\n        var result = { top: 10 };\n        var side = pos[0] < size.viewSize[0] / 2 ? 'right' : 'left';\n        result[side] = 60;\n        return result;\n      },\n      formatter: function formatter(options) {\n        var tpl = [];\n        tpl.push(options[0].axisValue + '<br>');\n        options.forEach(function (option) {\n          var data = option.data,\n              seriesName = option.seriesName,\n              componentSubType = option.componentSubType,\n              color = option.color;\n\n          var name = labelMap[seriesName] == null ? seriesName : labelMap[seriesName];\n          tpl.push(itemPoint(color) + ' ' + name + ': ');\n          if (componentSubType === 'candlestick') {\n            tpl.push('<br>');\n            metrics.slice(0, 4).forEach(function (m, i) {\n              var name = labelMap[m] != null ? labelMap[m] : m;\n              var val = getFormated(data[i + 1], dataType, digit);\n              tpl.push('- ' + name + ': ' + val + '<br>');\n            });\n          } else if (componentSubType === 'line') {\n            var val = getFormated(data, dataType, digit);\n            tpl.push(val + '<br>');\n          } else if (componentSubType === 'bar') {\n            var _val = getFormated(data[1], dataType, digit);\n            tpl.push(_val + '<br>');\n          }\n        });\n        return tpl.join('');\n      }\n    };\n  }\n\n  function getCandleVisualMap(args) {\n    var downColor = args.downColor,\n        upColor = args.upColor,\n        MA = args.MA,\n        showMA = args.showMA;\n\n    return {\n      show: false,\n      seriesIndex: showMA ? 1 + MA.length : 1,\n      dimension: 2,\n      pieces: [{ value: 1, color: downColor }, { value: -1, color: upColor }]\n    };\n  }\n\n  function getCandleGrid(args) {\n    var showVol = args.showVol;\n\n    return [{\n      left: '10%',\n      right: '8%',\n      top: '10%',\n      height: showVol ? '50%' : '65%',\n      containLabel: false\n    }, {\n      left: '10%',\n      right: '8%',\n      top: '65%',\n      height: '16%',\n      containLabel: false\n    }];\n  }\n\n  function getCandleXAxis(args) {\n    var data = args.dims;\n\n    var type = 'category';\n    var scale = true;\n    var boundaryGap = false;\n    var splitLine = SHOW_FALSE;\n    var axisLine = { onZero: false };\n    var axisTick = SHOW_FALSE;\n    var axisLabel = SHOW_FALSE;\n    var min = 'dataMin';\n    var max = 'dataMax';\n    var gridIndex = 1;\n\n    return [{ type: type, data: data, scale: scale, boundaryGap: boundaryGap, axisLine: axisLine, splitLine: splitLine, min: min, max: max }, { type: type, gridIndex: gridIndex, data: data, scale: scale, boundaryGap: boundaryGap, axisLine: axisLine, axisTick: axisTick, splitLine: splitLine, axisLabel: axisLabel, min: min, max: max }];\n  }\n\n  function getCandleYAxis(args) {\n    var dataType = args.dataType,\n        digit = args.digit;\n\n    var scale = true;\n    var gridIndex = 1;\n    var splitNumber = 2;\n    var axisLine = SHOW_FALSE;\n    var axisTick = SHOW_FALSE;\n    var axisLabel = SHOW_FALSE;\n    var splitLine = SHOW_FALSE;\n    var formatter = function formatter(val) {\n      return getFormated(val, dataType, digit);\n    };\n\n    return [{ scale: scale, axisTick: axisTick, axisLabel: { formatter: formatter } }, { scale: scale, gridIndex: gridIndex, splitNumber: splitNumber, axisLine: axisLine, axisTick: axisTick, splitLine: splitLine, axisLabel: axisLabel }];\n  }\n\n  function getCandleDataZoom(args) {\n    var start = args.start,\n        end = args.end;\n\n\n    return [{\n      type: 'inside',\n      xAxisIndex: [0, 1],\n      start: start,\n      end: end\n    }, {\n      show: true,\n      xAxisIndex: [0, 1],\n      type: 'slider',\n      top: '85%',\n      start: start,\n      end: end\n    }];\n  }\n\n  function getCandleSeries(args) {\n    var values = args.values,\n        volumes = args.volumes,\n        upColor = args.upColor,\n        downColor = args.downColor,\n        showMA = args.showMA,\n        MA = args.MA,\n        showVol = args.showVol,\n        labelMap = args.labelMap,\n        digit = args.digit,\n        itemStyle = args.itemStyle;\n\n    var style = itemStyle || {\n      normal: {\n        color: upColor,\n        color0: downColor,\n        borderColor: null,\n        borderColor0: null\n      }\n    };\n    var lineStyle = { normal: { opacity: 0.5 } };\n    var series = [{\n      name: labelMap[DEFAULT_K_NAME] == null ? DEFAULT_K_NAME : labelMap[DEFAULT_K_NAME],\n      type: 'candlestick',\n      data: values,\n      itemStyle: style\n    }];\n\n    if (showMA) {\n      MA.forEach(function (d) {\n        var name = 'MA' + d;\n        series.push({\n          name: labelMap[name] == null ? name : labelMap[name],\n          data: calculateMA(d, values, digit),\n          type: 'line',\n          lineStyle: lineStyle,\n          smooth: true\n        });\n      });\n    }\n\n    if (showVol) {\n      series.push({\n        name: 'Volume',\n        type: 'bar',\n        xAxisIndex: 1,\n        yAxisIndex: 1,\n        data: volumes\n      });\n    }\n\n    return series;\n  }\n\n  function calculateMA(dayCount, data, digit) {\n    var result = [];\n    data.forEach(function (d, i) {\n      if (i < dayCount) {\n        result.push('-');\n      } else {\n        var sum = 0;\n        for (var j = 0; j < dayCount; j++) {\n          sum += data[i - j][1];\n        }result.push(+(sum / dayCount).toFixed(digit));\n      }\n    });\n    return result;\n  }\n\n  var candle = function candle(columns, rows, settings, status) {\n    var _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$metrics = settings.metrics,\n        metrics = _settings$metrics === undefined ? columns.slice(1, 6) : _settings$metrics,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        itemStyle = settings.itemStyle,\n        _settings$labelMap = settings.labelMap,\n        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,\n        _settings$legendName = settings.legendName,\n        legendName = _settings$legendName === undefined ? {} : _settings$legendName,\n        _settings$MA = settings.MA,\n        MA = _settings$MA === undefined ? DEFAULT_MA : _settings$MA,\n        _settings$showMA = settings.showMA,\n        showMA = _settings$showMA === undefined ? false : _settings$showMA,\n        _settings$showVol = settings.showVol,\n        showVol = _settings$showVol === undefined ? false : _settings$showVol,\n        _settings$showDataZoo = settings.showDataZoom,\n        showDataZoom = _settings$showDataZoo === undefined ? false : _settings$showDataZoo,\n        _settings$downColor = settings.downColor,\n        downColor = _settings$downColor === undefined ? DEFAULT_DOWN_COLOR : _settings$downColor,\n        _settings$upColor = settings.upColor,\n        upColor = _settings$upColor === undefined ? DEFAULT_UP_COLOR : _settings$upColor,\n        _settings$start = settings.start,\n        start = _settings$start === undefined ? DEFAULT_START : _settings$start,\n        _settings$end = settings.end,\n        end = _settings$end === undefined ? DEFAULT_END : _settings$end,\n        dataType = settings.dataType;\n    var tooltipVisible = status.tooltipVisible,\n        legendVisible = status.legendVisible;\n\n\n    var isLiteData = isArray(rows[0]);\n    var dims = [];\n    var values = [];\n    var volumes = [];\n    var candleMetrics = metrics.slice(0, 4);\n    var volumeMetrics = metrics[4];\n\n    if (isLiteData) {\n      rows.forEach(function (row) {\n        var itemResult = [];\n        dims.push(row[columns.indexOf(dimension)]);\n        candleMetrics.forEach(function (item) {\n          itemResult.push(row[columns.indexOf(item)]);\n        });\n        values.push(itemResult);\n        if (volumeMetrics) volumes.push(row[columns.indexOf(volumeMetrics)]);\n      });\n    } else {\n      rows.forEach(function (row, index) {\n        var itemResult = [];\n        dims.push(row[dimension]);\n        candleMetrics.forEach(function (item) {\n          itemResult.push(row[item]);\n        });\n        values.push(itemResult);\n        if (volumeMetrics) {\n          var _status = row[metrics[0]] > row[metrics[1]] ? 1 : -1;\n          volumes.push([index, row[volumeMetrics], _status]);\n        }\n      });\n    }\n\n    var legend$$1 = legendVisible && getCandleLegend({ showMA: showMA, MA: MA, legendName: legendName, labelMap: labelMap });\n    var tooltip$$1 = tooltipVisible && getCandleTooltip({ metrics: metrics, dataType: dataType, digit: digit, labelMap: labelMap });\n    var visualMap$$1 = showVol && getCandleVisualMap({ downColor: downColor, upColor: upColor, MA: MA, showMA: showMA });\n    var dataZoom$$1 = showDataZoom && getCandleDataZoom({ start: start, end: end });\n    var grid = getCandleGrid({ showVol: showVol });\n    var xAxis = getCandleXAxis({ dims: dims });\n    var yAxis = getCandleYAxis({ dataType: dataType, digit: digit });\n    var series = getCandleSeries({\n      values: values,\n      volumes: volumes,\n      upColor: upColor,\n      downColor: downColor,\n      showMA: showMA,\n      MA: MA,\n      showVol: showVol,\n      labelMap: labelMap,\n      digit: digit,\n      itemStyle: itemStyle\n    });\n    var axisPointer = { link: { xAxisIndex: 'all' } };\n    return { legend: legend$$1, tooltip: tooltip$$1, visualMap: visualMap$$1, grid: grid, xAxis: xAxis, yAxis: yAxis, dataZoom: dataZoom$$1, series: series, axisPointer: axisPointer };\n  };\n\n  var VeCandle = _extends({}, Core, {\n    name: 'VeCandle',\n    data: function data() {\n      this.chartHandler = candle;\n      return {};\n    }\n  });\n\n  function getTooltip$3(args) {\n    var tooltipFormatter = args.tooltipFormatter,\n        dataType = args.dataType,\n        digit = args.digit;\n\n    return {\n      formatter: function formatter(options) {\n        var seriesName = options.seriesName,\n            _options$data = options.data,\n            value = _options$data.value,\n            name = _options$data.name;\n\n        if (tooltipFormatter) {\n          return tooltipFormatter.apply(null, arguments);\n        }\n        var tpl = [];\n        tpl.push(seriesName + ': ');\n        tpl.push(getFormated(value, dataType[seriesName], digit) + ' ' + name);\n        return tpl.join('');\n      }\n    };\n  }\n\n  function getSeries$3(args) {\n    var rows = args.rows,\n        dimension = args.dimension,\n        metrics = args.metrics,\n        digit = args.digit,\n        dataType = args.dataType,\n        labelMap = args.labelMap,\n        seriesMap = args.seriesMap,\n        dataName = args.dataName;\n\n\n    var series = rows.map(function (row) {\n      var label = row[dimension];\n      var seriesItem = seriesMap[label];\n      var result = {\n        type: 'gauge',\n        name: labelMap[label] != null ? labelMap[label] : label,\n        data: [{\n          name: dataName[label] || '',\n          value: row[metrics]\n        }],\n        detail: {\n          formatter: function formatter(v) {\n            return getFormated(v, dataType[label], digit);\n          }\n        },\n        axisLabel: {\n          formatter: function formatter(v) {\n            return getFormated(v, dataType[label], digit);\n          }\n        }\n      };\n\n      if (seriesItem) {\n        Object.keys(seriesItem).forEach(function (key) {\n          if (isObject(result[key])) {\n            _extends(result[key], seriesItem[key]);\n          } else {\n            result[key] = seriesItem[key];\n          }\n        });\n      }\n\n      return result;\n    });\n\n    return series;\n  }\n\n  var gauge$1 = function gauge$$1(columns, rows, settings, extra) {\n    var _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$metrics = settings.metrics,\n        metrics = _settings$metrics === undefined ? columns[1] : _settings$metrics,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? {} : _settings$dataType,\n        _settings$labelMap = settings.labelMap,\n        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,\n        _settings$seriesMap = settings.seriesMap,\n        seriesMap = _settings$seriesMap === undefined ? {} : _settings$seriesMap,\n        _settings$dataName = settings.dataName,\n        dataName = _settings$dataName === undefined ? {} : _settings$dataName;\n    var tooltipFormatter = extra.tooltipFormatter,\n        tooltipVisible = extra.tooltipVisible;\n\n\n    var tooltip$$1 = tooltipVisible && getTooltip$3({\n      tooltipFormatter: tooltipFormatter,\n      dataType: dataType\n    });\n\n    var series = getSeries$3({\n      rows: rows,\n      dimension: dimension,\n      metrics: metrics,\n      digit: digit,\n      dataType: dataType,\n      labelMap: labelMap,\n      seriesMap: seriesMap,\n      dataName: dataName\n    });\n    return { tooltip: tooltip$$1, series: series };\n  };\n\n  var VeGauge = _extends({}, Core, {\n    name: 'VeGauge',\n    data: function data() {\n      this.chartHandler = gauge$1;\n      return {};\n    }\n  });\n\n  function getTreeLegend(args) {\n    var dimension = args.dimension,\n        rows = args.rows;\n\n    var result = rows.map(function (row) {\n      return row[dimension];\n    });\n    return { data: result };\n  }\n\n  function getTreeTooltip(args) {\n    var tooltipFormatter = args.tooltipFormatter;\n\n\n    return {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: tooltipFormatter\n    };\n  }\n\n  function getTreeSeries(args) {\n    var dimension = args.dimension,\n        metrics = args.metrics,\n        rows = args.rows,\n        seriesMap = args.seriesMap;\n\n\n    var series = [];\n    rows.forEach(function (row) {\n      var label = row[dimension];\n      var seriesItem = seriesMap[label];\n      var result = {\n        type: 'tree',\n        name: row[dimension],\n        data: row[metrics]\n      };\n      if (seriesMap[row[dimension]]) {\n        Object.keys(seriesItem).forEach(function (key) {\n          if (isObject(result[key])) {\n            _extends(result[key], seriesItem[key]);\n          } else {\n            result[key] = seriesItem[key];\n          }\n        });\n      }\n      series.push(result);\n    });\n\n    return series;\n  }\n\n  var tree$1 = function tree$$1(columns, rows, settings, extra) {\n    var _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$metrics = settings.metrics,\n        metrics = _settings$metrics === undefined ? columns[1] : _settings$metrics,\n        _settings$seriesMap = settings.seriesMap,\n        seriesMap = _settings$seriesMap === undefined ? {} : _settings$seriesMap;\n    var legendVisible = extra.legendVisible,\n        tooltipFormatter = extra.tooltipFormatter,\n        tooltipVisible = extra.tooltipVisible;\n\n\n    var series = getTreeSeries({\n      dimension: dimension,\n      metrics: metrics,\n      rows: rows,\n      seriesMap: seriesMap\n    });\n    var legend$$1 = legendVisible && rows.length > 1 && getTreeLegend({\n      dimension: dimension,\n      rows: rows\n    });\n    var tooltip$$1 = tooltipVisible && getTreeTooltip({\n      tooltipFormatter: tooltipFormatter\n    });\n    return { series: series, legend: legend$$1, tooltip: tooltip$$1 };\n  };\n\n  var VeTree = _extends({}, Core, {\n    name: 'VeTree',\n    data: function data() {\n      this.chartHandler = tree$1;\n      return {};\n    }\n  });\n\n  function getTooltip$4(args) {\n    var tooltipFormatter = args.tooltipFormatter,\n        dataType = args.dataType,\n        digit = args.digit;\n\n\n    return {\n      show: true,\n      formatter: function formatter(options) {\n        var seriesName = options.seriesName,\n            value = options.value;\n\n        if (tooltipFormatter) {\n          return tooltipFormatter.apply(null, arguments);\n        }\n\n        return [seriesName + ': ', getFormated(value, dataType, digit)].join('');\n      }\n    };\n  }\n\n  function getSeries$4(args) {\n    var dimension = args.dimension,\n        metrics = args.metrics,\n        seriesMap = args.seriesMap,\n        rows = args.rows,\n        wave = args.wave;\n\n\n    var itemWave = wave;\n    var len = isArray(seriesMap) ? seriesMap.length : 0;\n\n    return rows.slice().map(function (item, index) {\n      var data = [];\n      var result = {\n        type: 'liquidFill'\n      };\n\n      var name = item[dimension];\n      var val = Number(item[metrics]);\n      var itemMap = {};\n\n      if (isArray(seriesMap)) {\n        itemMap = !seriesMap[index] ? seriesMap[len - 1] : seriesMap[index];\n      } else if (isObject(seriesMap[name])) {\n        itemMap = seriesMap[name];\n      }\n\n      if (isArray(wave) && isArray(wave[0])) {\n        itemWave = isArray(wave[index]) ? wave[index] : wave[wave.length - 1];\n      }\n\n      // (rows)(seriesMap)data\n      data.push({ value: val });\n      if (itemWave && itemWave.length) {\n        data = data.concat(itemWave.map(function (val) {\n          return { value: val };\n        }));\n      }\n\n      result = _extends(result, { data: data, name: name }, itemMap);\n      return result;\n    });\n  }\n\n  var liquidfill = function liquidfill(columns, rows, settings, extra) {\n    var _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$metrics = settings.metrics,\n        metrics = _settings$metrics === undefined ? columns[1] : _settings$metrics,\n        _settings$seriesMap = settings.seriesMap,\n        seriesMap = _settings$seriesMap === undefined ? {} : _settings$seriesMap,\n        _settings$dataType = settings.dataType,\n        dataType = _settings$dataType === undefined ? 'percent' : _settings$dataType,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        _settings$wave = settings.wave,\n        wave = _settings$wave === undefined ? [] : _settings$wave;\n    var tooltipVisible = extra.tooltipVisible,\n        tooltipFormatter = extra.tooltipFormatter;\n\n\n    var tooltip$$1 = tooltipVisible && getTooltip$4({\n      tooltipFormatter: tooltipFormatter,\n      dataType: dataType,\n      digit: digit\n    });\n    var series = getSeries$4({\n      rows: rows,\n      columns: columns,\n      dimension: dimension,\n      metrics: metrics,\n      seriesMap: seriesMap,\n      wave: wave\n    });\n\n    return {\n      tooltip: tooltip$$1,\n      series: series\n    };\n  };\n\n  var VeLiquidfill = _extends({}, Core, {\n    name: 'VeLiquidfill',\n    data: function data() {\n      this.chartHandler = liquidfill;\n      return {};\n    }\n  });\n\n  function getSeries$5(args) {\n    var dimension = args.dimension,\n        metrics = args.metrics,\n        rows = args.rows,\n        color = args.color,\n        sizeMax = args.sizeMax,\n        sizeMin = args.sizeMin,\n        shape = args.shape;\n\n\n    var baseType = {\n      type: 'wordCloud',\n      textStyle: {\n        normal: {\n          color: !isArray(color) && !!color ? color : function () {\n            return 'rgb(' + [Math.round(Math.random() * 160), Math.round(Math.random() * 160), Math.round(Math.random() * 160)].join(',') + ')';\n          }\n        }\n      },\n      shape: shape,\n      sizeRange: [sizeMin, sizeMax]\n    };\n\n    var len = isArray(color) ? color.length : 0;\n    var data = rows.slice().map(function (row) {\n      var text = {\n        name: row[dimension],\n        value: row[metrics]\n      };\n\n      if (len > 0) {\n        text.textStyle = {\n          normal: {\n            color: color[Math.floor(Math.random() * len)]\n          }\n        };\n      }\n      return text;\n    });\n\n    baseType.data = data;\n\n    return [baseType];\n  }\n\n  function getTooltip$5(args) {\n    var tooltipFormatter = args.tooltipFormatter;\n\n\n    return {\n      show: true,\n      formatter: function formatter(params) {\n        var _params$data = params.data,\n            name = _params$data.name,\n            value = _params$data.value;\n\n\n        if (tooltipFormatter) {\n          return tooltipFormatter.apply(null, params);\n        }\n\n        return name + ': ' + value;\n      }\n    };\n  }\n\n  var wordcloud = function wordcloud(columns, rows, settings, extra) {\n    var _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,\n        _settings$metrics = settings.metrics,\n        metrics = _settings$metrics === undefined ? columns[1] : _settings$metrics,\n        _settings$color = settings.color,\n        color = _settings$color === undefined ? '' : _settings$color,\n        _settings$sizeMax = settings.sizeMax,\n        sizeMax = _settings$sizeMax === undefined ? 60 : _settings$sizeMax,\n        _settings$sizeMin = settings.sizeMin,\n        sizeMin = _settings$sizeMin === undefined ? 12 : _settings$sizeMin,\n        _settings$shape = settings.shape,\n        shape = _settings$shape === undefined ? 'circle' : _settings$shape;\n    var tooltipVisible = extra.tooltipVisible,\n        tooltipFormatter = extra.tooltipFormatter;\n\n\n    var series = getSeries$5({ dimension: dimension, metrics: metrics, rows: rows, color: color, sizeMax: sizeMax, sizeMin: sizeMin, shape: shape });\n    var tooltip$$1 = tooltipVisible && getTooltip$5({ tooltipFormatter: tooltipFormatter });\n\n    return {\n      series: series,\n      tooltip: tooltip$$1\n    };\n  };\n\n  var VeWordcloud = _extends({}, Core, {\n    name: 'VeWordcloud',\n    data: function data() {\n      this.chartHandler = wordcloud;\n      return {};\n    }\n  });\n\n  var components = [VeBar, VeHistogram, VeLine, VePie, VeRing, VeWaterfall, VeFunnel, VeRadar, VeChart, VeMap, VeBmap, VeAmap, VeSankey, VeHeatmap, VeScatter, VeCandle, VeGauge, VeTree, VeLiquidfill, VeWordcloud];\n\n  function install(Vue, _) {\n    components.forEach(function (component) {\n      Vue.component(component.name, component);\n    });\n  }\n\n  if (typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue);\n  }\n\n  var index = {\n    VeBar: VeBar,\n    VeHistogram: VeHistogram,\n    VeRing: VeRing,\n    VeLine: VeLine,\n    VePie: VePie,\n    VeWaterfall: VeWaterfall,\n    VeFunnel: VeFunnel,\n    VeRadar: VeRadar,\n    VeChart: VeChart,\n    VeMap: VeMap,\n    VeBmap: VeBmap,\n    VeAmap: VeAmap,\n    VeSankey: VeSankey,\n    VeScatter: VeScatter,\n    VeCandle: VeCandle,\n    VeGauge: VeGauge,\n    VeTree: VeTree,\n    VeLiquidfill: VeLiquidfill,\n    VeWordcloud: VeWordcloud,\n    install: install\n  };\n\n  return index;\n\n})));\n","/**\n  * vue-class-component v7.1.0\n  * (c) 2015-present Evan You\n  * @license MIT\n  */\nimport Vue from 'vue';\n\n// The rational behind the verbose Reflect-feature check below is the fact that there are polyfills\n// which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.\n// Without this check consumers will encounter hard to track down runtime errors.\nvar reflectionIsSupported = typeof Reflect !== 'undefined' && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;\nfunction copyReflectionMetadata(to, from) {\n    forwardMetadata(to, from);\n    Object.getOwnPropertyNames(from.prototype).forEach(function (key) {\n        forwardMetadata(to.prototype, from.prototype, key);\n    });\n    Object.getOwnPropertyNames(from).forEach(function (key) {\n        forwardMetadata(to, from, key);\n    });\n}\nfunction forwardMetadata(to, from, propertyKey) {\n    var metaKeys = propertyKey\n        ? Reflect.getOwnMetadataKeys(from, propertyKey)\n        : Reflect.getOwnMetadataKeys(from);\n    metaKeys.forEach(function (metaKey) {\n        var metadata = propertyKey\n            ? Reflect.getOwnMetadata(metaKey, from, propertyKey)\n            : Reflect.getOwnMetadata(metaKey, from);\n        if (propertyKey) {\n            Reflect.defineMetadata(metaKey, metadata, to, propertyKey);\n        }\n        else {\n            Reflect.defineMetadata(metaKey, metadata, to);\n        }\n    });\n}\n\nvar fakeArray = { __proto__: [] };\nvar hasProto = fakeArray instanceof Array;\nfunction createDecorator(factory) {\n    return function (target, key, index) {\n        var Ctor = typeof target === 'function'\n            ? target\n            : target.constructor;\n        if (!Ctor.__decorators__) {\n            Ctor.__decorators__ = [];\n        }\n        if (typeof index !== 'number') {\n            index = undefined;\n        }\n        Ctor.__decorators__.push(function (options) { return factory(options, key, index); });\n    };\n}\nfunction mixins() {\n    var Ctors = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        Ctors[_i] = arguments[_i];\n    }\n    return Vue.extend({ mixins: Ctors });\n}\nfunction isPrimitive(value) {\n    var type = typeof value;\n    return value == null || (type !== 'object' && type !== 'function');\n}\nfunction warn(message) {\n    if (typeof console !== 'undefined') {\n        console.warn('[vue-class-component] ' + message);\n    }\n}\n\nfunction collectDataFromConstructor(vm, Component) {\n    // override _init to prevent to init as Vue instance\n    var originalInit = Component.prototype._init;\n    Component.prototype._init = function () {\n        var _this = this;\n        // proxy to actual vm\n        var keys = Object.getOwnPropertyNames(vm);\n        // 2.2.0 compat (props are no longer exposed as self properties)\n        if (vm.$options.props) {\n            for (var key in vm.$options.props) {\n                if (!vm.hasOwnProperty(key)) {\n                    keys.push(key);\n                }\n            }\n        }\n        keys.forEach(function (key) {\n            if (key.charAt(0) !== '_') {\n                Object.defineProperty(_this, key, {\n                    get: function () { return vm[key]; },\n                    set: function (value) { vm[key] = value; },\n                    configurable: true\n                });\n            }\n        });\n    };\n    // should be acquired class property values\n    var data = new Component();\n    // restore original _init to avoid memory leak (#209)\n    Component.prototype._init = originalInit;\n    // create plain data object\n    var plainData = {};\n    Object.keys(data).forEach(function (key) {\n        if (data[key] !== undefined) {\n            plainData[key] = data[key];\n        }\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        if (!(Component.prototype instanceof Vue) && Object.keys(plainData).length > 0) {\n            warn('Component class must inherit Vue or its descendant class ' +\n                'when class property is used.');\n        }\n    }\n    return plainData;\n}\n\nvar $internalHooks = [\n    'data',\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeDestroy',\n    'destroyed',\n    'beforeUpdate',\n    'updated',\n    'activated',\n    'deactivated',\n    'render',\n    'errorCaptured',\n    'serverPrefetch' // 2.6\n];\nfunction componentFactory(Component, options) {\n    if (options === void 0) { options = {}; }\n    options.name = options.name || Component._componentTag || Component.name;\n    // prototype props.\n    var proto = Component.prototype;\n    Object.getOwnPropertyNames(proto).forEach(function (key) {\n        if (key === 'constructor') {\n            return;\n        }\n        // hooks\n        if ($internalHooks.indexOf(key) > -1) {\n            options[key] = proto[key];\n            return;\n        }\n        var descriptor = Object.getOwnPropertyDescriptor(proto, key);\n        if (descriptor.value !== void 0) {\n            // methods\n            if (typeof descriptor.value === 'function') {\n                (options.methods || (options.methods = {}))[key] = descriptor.value;\n            }\n            else {\n                // typescript decorated data\n                (options.mixins || (options.mixins = [])).push({\n                    data: function () {\n                        var _a;\n                        return _a = {}, _a[key] = descriptor.value, _a;\n                    }\n                });\n            }\n        }\n        else if (descriptor.get || descriptor.set) {\n            // computed properties\n            (options.computed || (options.computed = {}))[key] = {\n                get: descriptor.get,\n                set: descriptor.set\n            };\n        }\n    });\n    (options.mixins || (options.mixins = [])).push({\n        data: function () {\n            return collectDataFromConstructor(this, Component);\n        }\n    });\n    // decorate options\n    var decorators = Component.__decorators__;\n    if (decorators) {\n        decorators.forEach(function (fn) { return fn(options); });\n        delete Component.__decorators__;\n    }\n    // find super\n    var superProto = Object.getPrototypeOf(Component.prototype);\n    var Super = superProto instanceof Vue\n        ? superProto.constructor\n        : Vue;\n    var Extended = Super.extend(options);\n    forwardStaticMembers(Extended, Component, Super);\n    if (reflectionIsSupported) {\n        copyReflectionMetadata(Extended, Component);\n    }\n    return Extended;\n}\nvar reservedPropertyNames = [\n    // Unique id\n    'cid',\n    // Super Vue constructor\n    'super',\n    // Component options that will be used by the component\n    'options',\n    'superOptions',\n    'extendOptions',\n    'sealedOptions',\n    // Private assets\n    'component',\n    'directive',\n    'filter'\n];\nvar shouldIgnore = {\n    prototype: true,\n    arguments: true,\n    callee: true,\n    caller: true\n};\nfunction forwardStaticMembers(Extended, Original, Super) {\n    // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable\n    Object.getOwnPropertyNames(Original).forEach(function (key) {\n        // Skip the properties that should not be overwritten\n        if (shouldIgnore[key]) {\n            return;\n        }\n        // Some browsers does not allow reconfigure built-in properties\n        var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);\n        if (extendedDescriptor && !extendedDescriptor.configurable) {\n            return;\n        }\n        var descriptor = Object.getOwnPropertyDescriptor(Original, key);\n        // If the user agent does not support `__proto__` or its family (IE <= 10),\n        // the sub class properties may be inherited properties from the super class in TypeScript.\n        // We need to exclude such properties to prevent to overwrite\n        // the component options object which stored on the extended constructor (See #192).\n        // If the value is a referenced value (object or function),\n        // we can check equality of them and exclude it if they have the same reference.\n        // If it is a primitive value, it will be forwarded for safety.\n        if (!hasProto) {\n            // Only `cid` is explicitly exluded from property forwarding\n            // because we cannot detect whether it is a inherited property or not\n            // on the no `__proto__` environment even though the property is reserved.\n            if (key === 'cid') {\n                return;\n            }\n            var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);\n            if (!isPrimitive(descriptor.value) &&\n                superDescriptor &&\n                superDescriptor.value === descriptor.value) {\n                return;\n            }\n        }\n        // Warn if the users manually declare reserved properties\n        if (process.env.NODE_ENV !== 'production' &&\n            reservedPropertyNames.indexOf(key) >= 0) {\n            warn(\"Static property name '\" + key + \"' declared on class '\" + Original.name + \"' \" +\n                'conflicts with reserved property name of Vue internal. ' +\n                'It may cause unexpected behavior of the component. Consider renaming the property.');\n        }\n        Object.defineProperty(Extended, key, descriptor);\n    });\n}\n\nfunction Component(options) {\n    if (typeof options === 'function') {\n        return componentFactory(options);\n    }\n    return function (Component) {\n        return componentFactory(Component, options);\n    };\n}\nComponent.registerHooks = function registerHooks(keys) {\n    $internalHooks.push.apply($internalHooks, keys);\n};\n\nexport default Component;\nexport { createDecorator, mixins };\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports[\"v-clipboard\"]=t():e[\"v-clipboard\"]=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,\"a\",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=\"/dist/\",t(t.s=0)}([function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var r=function(e){var t=document.createElement(\"textarea\"),n=void 0;if(\"string\"!=typeof e)try{n=JSON.stringify(e)}catch(e){throw\"Failed to copy value to clipboard. Unknown type.\"}else n=e;if(t.value=n,t.setAttribute(\"readonly\",\"\"),t.style.cssText=\"position:fixed;pointer-events:none;z-index:-9999;opacity:0;\",document.body.appendChild(t),navigator.userAgent.match(/ipad|ipod|iphone/i)){var r=t.contentEditable,o=t.readOnly;t.contentEditable=!0,t.readOnly=!0;var a=document.createRange();a.selectNodeContents(t);var i=window.getSelection();i.removeAllRanges(),i.addRange(a),t.setSelectionRange(0,999999),t.contentEditable=r,t.readOnly=o}else t.select();var c=!1;try{c=document.execCommand(\"copy\")}catch(e){console.warn(e)}return document.body.removeChild(t),c};t.default={install:function(e){e.prototype.$clipboard=r;var t=function(e){return function(){return\"$\"+e++}}(1),n={},o=function(e){e&&(n[e]=null,delete n[e])},a=function(e){var r=t();return n[r]=e,r};e.directive(\"clipboard\",{bind:function(e,t){var o=t.arg,i=t.value;switch(o){case\"error\":var c=a(i);return void(e.dataset.clipboardErrorHandler=c);case\"success\":var d=a(i);return void(e.dataset.clipboardSuccessHandler=d);default:var l=function(o){if(t.hasOwnProperty(\"value\")){var a={value:\"function\"==typeof i?i():i,event:o},c=r(a.value)?e.dataset.clipboardSuccessHandler:e.dataset.clipboardErrorHandler,d=n[c];d&&d(a)}},u=a(l);return e.dataset.clipboardClickHandler=u,void e.addEventListener(\"click\",n[u])}},unbind:function(e){var t=e.dataset,r=t.clipboardSuccessHandler,a=t.clipboardErrorHandler,i=t.clipboardClickHandler;o(r),o(a),i&&(e.removeEventListener(\"click\",n[i]),o(i))}})}}}])});\n//# sourceMappingURL=index.min.js.map"],"sourceRoot":""}